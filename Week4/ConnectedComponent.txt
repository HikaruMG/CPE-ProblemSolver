ปัญหานี้เกี่ยวข้องกับการหาจำนวน connected components ในกราฟที่ไม่มีทิศทาง (undirected graph) ซึ่งเราจะต้องหากลุ่มของจุดยอดที่เชื่อมต่อกัน (สามารถเดินทางจากจุดยอดหนึ่งไปยังจุดยอดอื่นได้โดยใช้เส้นเชื่อมในกราฟ) โดยการใช้ DFS (Depth-First Search) หรือ BFS (Breadth-First Search) เพื่อตรวจสอบการเชื่อมต่อของจุดยอดในกราฟ

หลักการคิด:

Graph Representation (การแทนกราฟ):

ใช้ adjacency list ในการเก็บข้อมูลการเชื่อมต่อระหว่างจุดยอดต่างๆ ในกราฟ
สำหรับกราฟที่มี n จุดยอดและ m เส้นเชื่อม, adjacency list จะช่วยให้สามารถจัดเก็บข้อมูลการเชื่อมต่อได้อย่างมีประสิทธิภาพ โดยที่ไม่ต้องใช้หน่วยความจำมากเกินไป (เหมาะสำหรับกราฟที่มีเส้นเชื่อมไม่มาก)
DFS:

เราจะเริ่มจากจุดยอดหนึ่ง (ซึ่งยังไม่ได้เยี่ยมชม) และทำการสำรวจจุดยอดทั้งหมดที่เชื่อมต่อถึงกันจากจุดยอดนั้นโดยใช้ DFS
เมื่อเจอจุดยอดที่ยังไม่เคยเยี่ยมชม เราจะเริ่มทำ DFS ที่จุดยอดนั้นและทำเครื่องหมายว่าเยี่ยมชมแล้ว
หลังจาก DFS เสร็จสิ้นแล้ว ทุกจุดยอดที่เราไปถึงใน DFS จะเป็นส่วนหนึ่งของ connected component หนึ่ง
ทำแบบนี้จนกว่าจะไม่มีจุดยอดที่ยังไม่ได้เยี่ยมชมเหลืออยู่
การนับจำนวน connected components:

ทุกครั้งที่เราเริ่มต้น DFS จากจุดยอดที่ยังไม่ได้เยี่ยมชม เราจะถือว่าเราเจอกลุ่ม connected component ใหม่
ดังนั้นจำนวนครั้งที่เราเริ่มต้น DFS จากจุดยอดที่ยังไม่ได้เยี่ยมชม จะเท่ากับจำนวน connected components ที่มีในกราฟ
การทำงานของโค้ด:
ประกาศตัวแปร:

graph: เป็นอาร์เรย์ของ pointers ที่ชี้ไปยังอาร์เรย์ของจุดยอดที่เชื่อมต่อกัน (adjacency list)
visited: เป็นอาร์เรย์ที่เก็บสถานะการเยี่ยมชมจุดยอด (ถ้าเยี่ยมชมแล้วจะเก็บค่า 1, ถ้ายังไม่เยี่ยมชมเก็บค่า 0)
การสร้างกราฟ:

กราฟจะถูกเก็บในรูปแบบ adjacency list ซึ่งเป็นการเก็บข้อมูลเชื่อมต่อระหว่างจุดยอดต่างๆ
สำหรับแต่ละเส้นเชื่อมที่ระบุในข้อมูล (a, b), เราจะเพิ่ม b ในรายการเพื่อนของ a และเพิ่ม a ในรายการเพื่อนของ b (กราฟไม่มีทิศทาง)
การทำ DFS:

ฟังก์ชัน dfs(int node) จะทำการสำรวจจุดยอดที่เชื่อมต่อกันทั้งหมดจากจุดยอด node ที่ยังไม่เยี่ยมชม โดยใช้การวนลูปผ่าน neighbors ของ node
ถ้าจุดยอดเพื่อน (neighbor) ยังไม่ถูกเยี่ยมชม ก็จะทำการเรียก DFS ที่จุดยอดนั้น
ในกระบวนการ DFS, ทุกจุดยอดที่เราไปถึงจะทำเครื่องหมายว่าเยี่ยมชมแล้วในอาร์เรย์ visited
การนับจำนวน connected components:

เริ่มต้นด้วยการวนลูปจากจุดยอดที่ 1 ถึง n (จุดยอดทั้งหมดในกราฟ)
ถ้าจุดยอดยังไม่ได้ถูกเยี่ยมชม (visited[i] == 0), จะเริ่มต้น DFS ที่จุดยอดนั้น และเพิ่มจำนวน connected component ขึ้น 1
เมื่อวนลูปเสร็จสิ้น จำนวน connected component จะเก็บจำนวนของกลุ่มจุดยอดที่เชื่อมต่อกันทั้งหมดในกราฟ
การจัดการหน่วยความจำ:

ใช้ malloc เพื่อจองหน่วยความจำสำหรับ adjacency list ของแต่ละจุดยอด (โดยใช้ graph[i] ซึ่งเป็น pointer ที่ชี้ไปที่อาร์เรย์ของ neighbors ของ i)
ใช้ free เพื่อคืนหน่วยความจำเมื่อเสร็จสิ้นการทำงาน

สรุป:
การสร้างกราฟ: เก็บข้อมูลเชื่อมต่อในรูปแบบ adjacency list
DFS: ใช้ DFS เพื่อสำรวจกราฟและทำเครื่องหมายว่าได้เยี่ยมชมจุดยอดแล้ว
การนับ connected components: ทุกครั้งที่พบจุดยอดที่ยังไม่ได้เยี่ยมชมจะเริ่มต้น DFS ใหม่และนับจำนวน connected components เพิ่มขึ้น
ประสิทธิภาพ: โค้ดนี้ทำงานในเวลา O(n + m) ซึ่งเหมาะสมสำหรับขนาดข้อมูลที่มีข้อจำกัดสูงสุด (n ≤ 100,000, m ≤ 200,000)