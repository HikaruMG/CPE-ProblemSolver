ปัญหานี้เกี่ยวข้องกับการหาจำนวน connected components ในกราฟที่ไม่มีทิศทาง (undirected graph) ซึ่งเราจะต้องหากลุ่มของจุดยอดที่เชื่อมต่อกัน (สามารถเดินทางจากจุดยอดหนึ่งไปยังจุดยอดอื่นได้โดยใช้เส้นเชื่อมในกราฟ) โดยการใช้ DFS (Depth-First Search) หรือ BFS (Breadth-First Search) เพื่อตรวจสอบการเชื่อมต่อของจุดยอดในกราฟ

หลักการคิด:

Graph Representation (การแทนกราฟ):
- ใช้ adjacency list ในการเก็บข้อมูลการเชื่อมต่อระหว่างจุดยอดต่างๆ ในกราฟ
- สำหรับกราฟที่มี n จุดยอดและ m เส้นเชื่อม, adjacency list จะช่วยให้สามารถจัดเก็บข้อมูลการเชื่อมต่อได้อย่างมีประสิทธิภาพ โดยที่ไม่ต้องใช้หน่วยความจำมากเกินไป (เหมาะสำหรับกราฟที่มีเส้นเชื่อมไม่มาก)

DFS:
- เราจะเริ่มจากจุดยอดหนึ่ง (ซึ่งยังไม่ได้เยี่ยมชม) และทำการสำรวจจุดยอดทั้งหมดที่เชื่อมต่อถึงกันจากจุดยอดนั้นโดยใช้ DFS
- เมื่อเจอจุดยอดที่ยังไม่เคยเยี่ยมชม เราจะเริ่มทำ DFS ที่จุดยอดนั้นและทำเครื่องหมายว่าเยี่ยมชมแล้ว
- หลังจาก DFS เสร็จสิ้นแล้ว ทุกจุดยอดที่เราไปถึงใน DFS จะเป็นส่วนหนึ่งของ connected component หนึ่ง
- ทำแบบนี้จนกว่าจะไม่มีจุดยอดที่ยังไม่ได้เยี่ยมชมเหลืออยู่

การนับจำนวน connected components:
- ทุกครั้งที่เราเริ่มต้น DFS จากจุดยอดที่ยังไม่ได้เยี่ยมชม เราจะถือว่าเราเจอกลุ่ม connected component ใหม่
- ดังนั้นจำนวนครั้งที่เราเริ่มต้น DFS จากจุดยอดที่ยังไม่ได้เยี่ยมชม จะเท่ากับจำนวน connected components ที่มีในกราฟ

การทำงานของโค้ด:

ประกาศตัวแปร:
- graph: เป็นอาร์เรย์ของ pointers ที่ชี้ไปยังอาร์เรย์ของจุดยอดที่เชื่อมต่อกัน (adjacency list)
- visited: เป็นอาร์เรย์ที่เก็บสถานะการเยี่ยมชมจุดยอด (ถ้าเยี่ยมชมแล้วจะเก็บค่า 1, ถ้ายังไม่เยี่ยมชมเก็บค่า 0)

การสร้างกราฟ:
- กราฟจะถูกเก็บในรูปแบบ adjacency list ซึ่งเป็นการเก็บข้อมูลเชื่อมต่อระหว่างจุดยอดต่างๆ
- สำหรับแต่ละเส้นเชื่อมที่ระบุในข้อมูล (a, b), เราจะเพิ่ม b ในรายการเพื่อนของ a และเพิ่ม a ในรายการเพื่อนของ b (กราฟไม่มีทิศทาง)

การทำ DFS:
- ฟังก์ชัน dfs(int node) จะทำการสำรวจจุดยอดที่เชื่อมต่อกันทั้งหมดจากจุดยอด node ที่ยังไม่เยี่ยมชม โดยใช้การวนลูปผ่าน neighbors ของ node
- ถ้าจุดยอดเพื่อน (neighbor) ยังไม่ถูกเยี่ยมชม ก็จะทำการเรียก DFS ที่จุดยอดนั้น
- ในกระบวนการ DFS, ทุกจุดยอดที่เราไปถึงจะทำเครื่องหมายว่าเยี่ยมชมแล้วในอาร์เรย์ visited

การนับจำนวน connected components:
- เริ่มต้นด้วยการวนลูปจากจุดยอดที่ 1 ถึง n (จุดยอดทั้งหมดในกราฟ)
- ถ้าจุดยอดยังไม่ได้ถูกเยี่ยมชม (visited[i] == 0), จะเริ่มต้น DFS ที่จุดยอดนั้น และเพิ่มจำนวน connected component ขึ้น 1

เมื่อวนลูปเสร็จสิ้น จำนวน connected component จะเก็บจำนวนของกลุ่มจุดยอดที่เชื่อมต่อกันทั้งหมดในกราฟ

การจัดการหน่วยความจำ:
- ใช้ malloc เพื่อจองหน่วยความจำสำหรับ adjacency list ของแต่ละจุดยอด (โดยใช้ graph[i] ซึ่งเป็น pointer ที่ชี้ไปที่อาร์เรย์ของ neighbors ของ i)
- ใช้ free เพื่อคืนหน่วยความจำเมื่อเสร็จสิ้นการทำงาน

สรุป:
- การสร้างกราฟ: เก็บข้อมูลเชื่อมต่อในรูปแบบ adjacency list
- DFS: ใช้ DFS เพื่อสำรวจกราฟและทำเครื่องหมายว่าได้เยี่ยมชมจุดยอดแล้ว
- การนับ connected components: ทุกครั้งที่พบจุดยอดที่ยังไม่ได้เยี่ยมชมจะเริ่มต้น DFS ใหม่และนับจำนวน connected components เพิ่มขึ้น
- ประสิทธิภาพ: โค้ดนี้ทำงานในเวลา O(n + m) ซึ่งเหมาะสมสำหรับขนาดข้อมูลที่มีข้อจำกัดสูงสุด (n ≤ 100,000, m ≤ 200,000)