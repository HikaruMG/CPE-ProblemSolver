หลักการคิดและการทำงานของโค้ดนี้คือการใช้ การค้นหาผ่านกราฟ (Graph Search) โดยใช้ Breadth-First Search (BFS) เพื่อหาว่าสามารถเดินจากตำแหน่งเริ่มต้นไปยังตำแหน่งปลายทางได้หรือไม่ โดยคำนึงถึงข้อกำหนดพิเศษของประตูที่ต้องใช้กุญแจในการเปิด และการที่กุญแจจะถูกใช้เพียงครั้งเดียวในแผนที่

หลักการคิด:
แผนที่และการเดินทาง:

แผนที่มีการกำหนดให้แต่ละช่องเป็นทางเดิน (.), กำแพง (#), และประตู (0).
หากคุณเจอประตู (0), คุณต้องใช้กุญแจเพื่อผ่านมัน ซึ่งแต่ละกุญแจใช้ได้แค่ครั้งเดียว
ทิศทางการเดินคือ ขึ้น, ลง, ซ้าย, ขวา ซึ่งจะถูกคำนวณในแต่ละขั้นตอน
การใช้ BFS ในการค้นหา:

การใช้ BFS ช่วยให้เราค้นหาทางไปยังจุดหมายจากจุดเริ่มต้นในลักษณะที่ประหยัดเวลาที่สุด โดยการเยี่ยมชมแต่ละตำแหน่งในแผนที่ทีละชั้น (Level by Level)
เริ่มจากจุดเริ่มต้นและทำการเดินไปตามตำแหน่งต่างๆ โดยไม่ข้ามกำแพง (#).
หากเจอประตู (0), เราจะต้องใช้กุญแจ และไม่สามารถใช้กุญแจได้อีกหากเราใช้แล้ว
การจัดการสถานะ:

สถานะของการใช้กุญแจมีสองประเภท:
0: ยังไม่ได้ใช้กุญแจ
1: ใช้กุญแจแล้ว
ใช้ queue เก็บตำแหน่งและสถานะการใช้กุญแจ ในการเยี่ยมชมแต่ละตำแหน่งเพื่อทำการค้นหาต่อไป
ติดตามตำแหน่งที่เคยเยี่ยมชมแล้วเพื่อหลีกเลี่ยงการเดินทางซ้ำ
การทำงานของโค้ด:
1. โครงสร้างข้อมูล:
maze (2D array): แผนที่เขาวงกตที่ประกอบด้วยช่องต่างๆ (., #, 0)
visited (3D array): เก็บสถานะการเยี่ยมชมแต่ละตำแหน่งในแผนที่ โดยใช้ 3 มิติ: visited[x][y][usedKey] ซึ่ง usedKey สามารถเป็น 0 หรือ 1 (ยังไม่ได้ใช้กุญแจ หรือใช้กุญแจแล้ว)
2. การเริ่มต้น BFS:
เริ่มจากตำแหน่ง (R, C) และใส่ลงใน queue โดยมีสถานะ usedKey = 0 (ยังไม่ใช้กุญแจ)
จากนั้นทำการค้นหาทุกตำแหน่งที่สามารถเดินไปได้ (ตามทิศทาง ขึ้น, ลง, ซ้าย, ขวา) โดยตรวจสอบ:
หากเป็น .: สามารถเดินผ่านได้
หากเป็น #: เป็นกำแพงไม่สามารถผ่านได้
หากเป็น 0: ต้องใช้กุญแจในการผ่าน
หากยังไม่ได้ใช้กุญแจ (usedKey = 0) จะใช้กุญแจแล้วเดินต่อไปที่ประตูนั้นโดยตั้งค่า usedKey = 1
หากใช้กุญแจแล้ว (usedKey = 1) จะไม่สามารถเดินผ่านประตูได้
3. การตอบคำถาม:
สำหรับแต่ละคำถามที่ให้มา เราจะเริ่มจากจุด (R, C) และใช้ BFS เพื่อหาว่าสามารถเดินไปถึงจุด (A, B) ได้หรือไม่
หากสามารถไปถึงได้ก็จะพิมพ์ yes, หากไม่สามารถไปถึงได้ก็จะพิมพ์ no

การทำงานหลัก:
เริ่มต้น BFS จากจุดเริ่มต้น (R, C): เราจะเพิ่มตำแหน่งเริ่มต้นใน queue โดยยังไม่ได้ใช้กุญแจ
เยี่ยมชมแต่ละตำแหน่ง: เราจะตรวจสอบทิศทางที่สามารถเดินไปได้และตรวจสอบว่าเราเคยเยี่ยมชมตำแหน่งนี้แล้วหรือไม่
ตรวจสอบการผ่านประตู: หากเจอประตู (0), เราจะต้องตรวจสอบว่าเรามีกุญแจหรือไม่ และใช้กุญแจได้แค่ครั้งเดียว
ตอบคำถาม: สำหรับแต่ละคำถามจะตรวจสอบว่าเราสามารถไปถึงตำแหน่งปลายทางได้หรือไม่