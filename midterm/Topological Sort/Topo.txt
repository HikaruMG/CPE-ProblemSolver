บทความ: ความแตกต่างและการทำงานของ DFS-based Topological Sort และ Kahn's Algorithm Topological Sort
Topological Sort หรือการเรียงลำดับตามลำดับขั้น เป็นอัลกอริทึมที่ใช้ในการจัดเรียงโหนดในกราฟแบบมีทิศทางและไม่มีวงจร (Directed Acyclic Graph หรือ DAG) 
เพื่อให้โหนดที่เป็น "ตัวก่อน" (dependencies) ปรากฏก่อนโหนดที่เป็น "ตัวหลัง" ในลำดับผลลัพธ์ อัลกอริทึมนี้มีประโยชน์ในหลายสถานการณ์ 
เช่น การจัดการลำดับงานที่มีความสัมพันธ์ การคอมไพล์โค้ดที่มี dependencies หรือการวิเคราะห์ตารางเรียนที่มีวิชาที่ต้องเรียนก่อน
ในบทความนี้ เราจะเปรียบเทียบสองวิธีหลักในการทำ Topological Sort ได้แก่ DFS-based Topological Sort (ใช้ Depth-First Search) 
และ Kahn's Algorithm Topological Sort (ใช้ Queue) โดยอธิบายการทำงาน ข้อดี-ข้อเสีย และความแตกต่างอย่างละเอียด

===================================================================================================================
DFS-based Topological Sort
การทำงาน
DFS-based Topological Sort ใช้การสำรวจกราฟแบบ Depth-First Search (DFS) ซึ่งเป็นวิธีการสำรวจที่ลงลึกไปยังโหนดที่เชื่อมต่อก่อนจะย้อนกลับมาสำรวจโหนดอื่น ขั้นตอนการทำงานมีดังนี้:

1. สำรวจโหนดด้วย DFS:
- เริ่มจากโหนดใดโหนดหนึ่งในกราฟ
- สำรวจโหนดที่เชื่อมต่อทั้งหมด (neighbors) โดยเรียก DFS ซ้ำสำหรับโหนดที่ยังไม่ถูกเยี่ยม
- เมื่อสำรวจโหนดที่เชื่อมต่อทั้งหมดของโหนดปัจจุบันเสร็จสิ้น ให้เพิ่มโหนดปัจจุบันลงใน stack

2. สร้างลำดับ:
- ทำขั้นตอนนี้สำหรับทุกโหนดที่ยังไม่ถูกเยี่ยมในกราฟ
- เมื่อสำรวจครบทุกโหนด stack จะเก็บลำดับโหนดในลักษณะ post-order
- ดึงโหนดจาก stack (จากบนลงล่าง) เพื่อให้ได้ลำดับ topological order

3. ผลลัพธ์:
- ลำดับที่ได้จาก stack จะเป็น topological order ที่ถูกต้อง โดยโหนดที่ไม่มีขอบออก (leaf nodes) จะถูกเพิ่มใน stack ก่อน และโหนดที่มีขอบออกจะถูกเพิ่มในภายหลัง

ข้อดี
- ง่ายต่อการ implement: ใช้โครงสร้างข้อมูลพื้นฐาน เช่น stack และ recursion
- เหมาะกับกราฟที่ซับซ้อน: สามารถจัดการกราฟที่มีโครงสร้างซับซ้อนได้ดี
- ใช้หน่วยความจำน้อย: ใช้หน่วยความจำเพียง O(V) สำหรับ stack และ array visited

ข้อเสีย
- ตรวจจับวงจรยาก: หากกราฟมีวงจร (cycle) จะต้องเพิ่มโค้ดพิเศษเพื่อตรวจจับ เช่น การใช้ array เพื่อตรวจสอบโหนดที่อยู่ใน recursion stack
- ลำดับอาจไม่แน่นอน: ลำดับที่ได้อาจแตกต่างกันขึ้นอยู่กับจุดเริ่มต้นของ DFS

ความซับซ้อน
- Time Complexity: O(V + E) โดย V = จำนวนโหนด และ E = จำนวนขอบ
- Space Complexity: O(V) สำหรับ stack และ array visited

ตัวอย่างการทำงาน
อินพุต:
5 4
1 2
2 3
1 3
1 5

1. สร้างกราฟ:
- graph[1] = {2, 3, 5}
- graph[2] = {3}
- graph[3] = {}
- graph[4] = {}
- graph[5] = {}

2. เรียก DFS:
- เริ่มที่ 1:
  - เยี่ยม 2 → เยี่ยม 3 (ใส่ 3 ใน stack)
  - กลับมาที่ 2 (ใส่ 2 ใน stack)
  - จาก 1 → เยี่ยม 5 (ใส่ 5 ใน stack)
  - กลับมาที่ 1 (ใส่ 1 ใน stack)
- เริ่มที่ 4:
  - เยี่ยม 4 (ใส่ 4 ใน stack)

3. stack: [4, 1, 5, 2, 3]

4. ผลลัพธ์: 4 1 5 2 3

=================================================================================================================

Kahn's Algorithm Topological Sort
การทำงาน
Kahn's Algorithm ใช้แนวคิดของ in-degree (จำนวนขอบที่ชี้เข้ามายังโหนด) และ Queue เพื่อประมวลผลโหนดตามลำดับ ขั้นตอนการทำงานมีดังนี้:

1. คำนวณ in-degree:
- สร้างกราฟแบบ adjacency list และคำนวณ in-degree ของทุกโหนด

2. หาโหนดเริ่มต้น:
- หาโหนดที่มี in-degree = 0 (ไม่มีขอบชี้เข้ามา) และใส่ลงในคิว

3. ประมวลผลด้วย Queue:
- นำโหนดออกจากคิว
- เพิ่มโหนดนั้นในผลลัพธ์
- ลด in-degree ของโหนดที่เชื่อมต่อ (neighbors) ของโหนดปัจจุบัน
- หาก in-degree ของโหนดใดลดลงเหลือ 0 ให้เพิ่มโหนดนั้นลงในคิว
- ทำซ้ำจนกว่าคิวจะว่าง

4. ตรวจสอบผลลัพธ์:
- หากจำนวนโหนดในผลลัพธ์เท่ากับจำนวนโหนดทั้งหมด แปลว่าสำเร็จ
- หากไม่เท่ากัน แปลว่ากราฟมีวงจร

ข้อดี
- ตรวจจับวงจรได้ง่าย: สามารถตรวจจับวงจรได้โดยดูจากจำนวนโหนดในผลลัพธ์
- เหมาะกับงานตามลำดับ: ให้ลำดับที่ชัดเจนตามขั้นตอน เหมาะกับการจัดการงานที่มี dependencies
- เข้าใจง่าย: การทำงานเป็นขั้นตอนและใช้โครงสร้างข้อมูลที่คุ้นเคย (Queue)

ข้อเสีย
- ต้องคำนวณ in-degree ล่วงหน้า: ต้องใช้เวลาเพิ่มเติมในการสร้าง array in-degree
- ใช้หน่วยความจำมากกว่าเล็กน้อย: ต้องใช้หน่วยความจำสำหรับ array in-degree และ Queue

ความซับซ้อน
- Time Complexity: O(V + E) โดย V = จำนวนโหนด และ E = จำนวนขอบ
- Space Complexity: O(V) สำหรับ Queue, array in-degree, และผลลัพธ์

ตัวอย่างการทำงาน
อินพุต:
5 4
1 2
2 3
1 3
1 5

1. สร้างกราฟและ in-degree:
- graph[1] = {2, 3, 5}
- graph[2] = {3}
- graph[3] = {}
- graph[4] = {}
- graph[5] = {}
- inDegree = [0, 0, 1, 2, 0, 1]

2. เรียก Kahn's:
- คิวเริ่มต้น: {1, 4}
- ดึง 1:
  - result: [1]
  - inDegree = [0, 0, 0, 1, 0, 0]
  - คิว: {4, 2, 5}
- ดึง 4:
  - result: [1, 4]
  - คิว: {2, 5}
- ดึง 2:
  - result: [1, 4, 2]
  - inDegree = [0, 0, 0, 0, 0, 0]
  - คิว: {5, 3}
ดึง 5:
  - result: [1, 4, 2, 5]
  - คิว: {3}
  - ดึง 3:

3. result: [1, 4, 2, 5, 3]

4. ผลลัพธ์: 1 4 2 5 3

สรุป:
  - DFS-based Topological Sort เหมาะสำหรับกรณีที่ต้องการความเรียบง่ายในการ implement และไม่จำเป็นต้องตรวจจับวงจร ลำดับที่ได้อาจแตกต่างกันขึ้นอยู่กับจุดเริ่มต้นของ DFS
  - Kahn's Algorithm Topological Sort เหมาะสำหรับกรณีที่ต้องการลำดับตามขั้นตอนที่ชัดเจนและต้องการตรวจจับวงจรในกราฟ ลำดับที่ได้มักสะท้อนถึงการประมวลผลตามลำดับขั้น
  
ทั้งสองวิธีให้ผลลัพธ์ที่ถูกต้องตามเงื่อนไขของ topological order (โหนดที่มีขอบชี้ไปยังโหนดอื่นจะมาก่อน) และมีความซับซ้อนด้านเวลาเท่ากันคือ O(V + E) 
การเลือกใช้วิธีใดขึ้นอยู่กับความต้องการของปัญหา เช่น การตรวจจับวงจร ความง่ายในการ implement หรือลักษณะของกราฟที่ต้องการประมวลผล