### การวิเคราะห์โจทย์

โจทย์นี้เป็นปัญหาการจัดสรรทรัพยากร (Resource Allocation) ที่ต้องการให้เราค้นหาจำนวนสูงสุดของสัปดาห์ที่เราสามารถจัดสรรเรือให้เพียงพอกับความต้องการของนักท่องเที่ยวได้ โดยมีเงื่อนไขดังนี้:

1. **ข้อมูลนำเข้า**:
   - จำนวนเรือทั้งหมด \(N\) และจำนวนสัปดาห์ที่ทราบข้อมูลการขอใช้เรือ \(M\)
   - ความจุของเรือ \(N\) ลำ (\(X_i\)) ซึ่งเป็นจำนวนเต็มบวก
   - ความต้องการนักท่องเที่ยวในแต่ละสัปดาห์ \(M\) สัปดาห์ (\(Y_j\)) ซึ่งเป็นจำนวนเต็มบวก

2. **เงื่อนไข**:
   - เรือแต่ละลำสามารถใช้ได้เพียงครั้งเดียว (เมื่อใช้แล้วจะไม่กลับมา)
   - ในแต่ละสัปดาห์ \(j\) ต้องจัดหาเรือที่มีความจุอย่างน้อย \(Y_j\)
   - ต้องการหาจำนวนสูงสุดของสัปดาห์ \(L\) ที่สามารถจัดสรรเรือได้ต่อเนื่องตั้งแต่สัปดาห์ที่ 1 ถึงสัปดาห์ที่ \(L\)

3. **เป้าหมาย**:
   - หาค่า \(L\) ที่มากที่สุดที่สามารถจัดสรรเรือได้ตั้งแต่สัปดาห์ที่ 1 ถึง \(L\)

4. **ตัวอย่าง**:
   - \(N = 5\), \(M = 6\)
   - ความจุเรือ: \(10, 20, 5, 7, 3\)
   - ความต้องการ: \(4, 17, 9, 50, 1, 2\)
   - ผลลัพธ์: \(3\) (สามารถจัดสรรได้ถึงสัปดาห์ที่ 3 เท่านั้น)

### ขั้นตอนการคิด

เพื่อแก้ปัญหานี้ เราใช้แนวคิด **Greedy Algorithm** โดยพิจารณาว่าในแต่ละสัปดาห์เราควรเลือกเรือที่มีความจุเพียงพอต่อความต้องการ (\(X_i \geq Y_j\)) และควรเลือกเรือที่มีความจุใกล้เคียงกับความต้องการมากที่สุด (แต่ไม่น้อยกว่า) เพื่อประหยัดเรือที่มีความจุสูงสำหรับความต้องการในอนาคตที่อาจมากกว่า ดังนั้นขั้นตอนการแก้ปัญหาคือ:

1. **จัดเรียงข้อมูล**:
   - จัดเก็บความจุของเรือ (\(X_i\)) และความต้องการในแต่ละสัปดาห์ (\(Y_j\)) ในโครงสร้างข้อมูลที่เหมาะสม
   - ใช้โครงสร้างข้อมูลเช่น Multiset (ใน C++ ใช้ `multiset`) เพื่อเก็บความจุของเรือ เพื่อให้สามารถค้นหาค่าเรือที่มีความจุมากกว่าหรือเท่ากับ \(Y_j\) ได้อย่างมีประสิทธิภาพ

2. **การเลือกเรือในแต่ละสัปดาห์**:
   - วนลูปตามความต้องการ \(Y_j\) ในแต่ละสัปดาห์ตั้งแต่ \(j = 1\) ถึง \(M\)
   - ในแต่ละสัปดาห์ \(j\):
     - ค้นหาเรือที่มีความจุอย่างน้อย \(Y_j\) (ใช้ `lower_bound` ใน `multiset`)
     - หากไม่มีเรือที่เหมาะสม (\(X_i < Y_j\) สำหรับทุก \(X_i\) ที่เหลือ) ให้หยุดการวนลูปและบันทึกจำนวนสัปดาห์ที่ทำได้
     - หากมีเรือที่เหมาะสม เลือกเรือที่มีความจุเพียงพอกับ \(Y_j\) และลบเรือลำนั้นออกจากชุดเรือ (เพราะใช้แล้วไม่กลับมา)
   - ดำเนินการต่อไปจนกว่าจะไม่สามารถจัดสรรเรือได้

3. **คำนวณผลลัพธ์**:
   - จำนวนสัปดาห์ที่สามารถจัดสรรเรือได้ต่อเนื่องคือ \(L\)

### โค้ด C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;

    // ใช้ multiset เพื่อเก็บความจุของเรือ (เรียงลำดับอัตโนมัติ)
    multiset<long long> boats;
    for (int i = 0; i < N; i++) {
        long long x;
        cin >> x;
        boats.insert(x);
    }

    // เก็บความต้องการในแต่ละสัปดาห์
    vector<long long> demands(M);
    for (int i = 0; i < M; i++) {
        cin >> demands[i];
    }

    int weeks = 0; // จำนวนสัปดาห์ที่สามารถจัดสรรได้
    for (int j = 0; j < M; j++) {
        long long y = demands[j]; // ความต้องการในสัปดาห์นี้
        // หาเรือที่มีความจุ >= y (ใช้ lower_bound)
        auto it = boats.lower_bound(y);
        if (it == boats.end()) {
            // ไม่มีเรือที่ใหญ่พอ
            break;
        }
        // ใช้เรือลำนี้และลบออก
        boats.erase(it);
        weeks++;
    }

    cout << weeks << endl;
    return 0;
}
```

### อธิบายโค้ดทีละส่วน

1. **การรวมไฟล์และเนมสเปซ**:
   ```cpp
   #include <bits/stdc++.h>
   using namespace std;
   ```
   - รวมไฟล์ส่วนหัวทั้งหมดที่จำเป็น (`iostream`, `set`, `vector` ฯลฯ) และใช้เนมสเปซ `std` เพื่อลดการเขียนคำนำหน้า

2. **รับข้อมูลนำเข้า**:
   ```cpp
   int N, M;
   cin >> N >> M;
   ```
   - รับจำนวนเรือ \(N\) และจำนวนสัปดาห์ \(M\)

3. **เก็บความจุของเรือ**:
   ```cpp
   multiset<long long> boats;
   for (int i = 0; i < N; i++) {
       long long x;
       cin >> x;
       boats.insert(x);
   }
   ```
   - ใช้ `multiset` เพื่อเก็บความจุของเรือ (\(X_i\)) ซึ่งจะเรียงลำดับอัตโนมัติและอนุญาตให้มีความจุซ้ำได้
   - ใช้ `long long` เพื่อรองรับค่าที่สูงถึง \(10^9\)

4. **เก็บความต้องการในแต่ละสัปดาห์**:
   ```cpp
   vector<long long> demands(M);
   for (int i = 0; i < M; i++) {
       cin >> demands[i];
   }
   ```
   - ใช้ `vector` เพื่อเก็บความต้องการในแต่ละสัปดาห์ (\(Y_j\))

5. **การจัดสรรเรือและคำนวณผลลัพธ์**:
   ```cpp
   int weeks = 0;
   for (int j = 0; j < M; j++) {
       long long y = demands[j];
       auto it = boats.lower_bound(y);
       if (it == boats.end()) {
           break;
       }
       boats.erase(it);
       weeks++;
   }
   ```
   - วนลูปตามจำนวนสัปดาห์ \(M\)
   - ในแต่ละรอบ:
     - หาความต้องการ \(Y_j\)
     - ใช้ `lower_bound` เพื่อค้นหาความจุของเรือที่มากกว่าหรือเท่ากับ \(Y_j\)
     - หากไม่พบ (ตัวชี้ไปที่ `end`) แปลว่าไม่มีเรือที่ใหญ่พอ ให้หยุดการวนลูป
     - หากพบ ลบเรือลำนั้นออกจาก `multiset` และเพิ่มจำนวนสัปดาห์ที่ทำได้

6. **แสดงผลลัพธ์**:
   ```cpp
   cout << weeks << endl;
   ```
   - แสดงจำนวนสัปดาห์สูงสุดที่สามารถจัดสรรเรือได้

### ตัวอย่างการทำงาน

**Input:**
```
5 6
10
20
5
7
3
4
17
9
50
1
2
```

**การประมวลผล:**
1. \(N = 5\), \(M = 6\)
2. ความจุเรือใน `multiset`: \(\{3, 5, 7, 10, 20\}\)
3. ความต้องการ: \(\{4, 17, 9, 50, 1, 2\}\)

- **สัปดาห์ 1 (\(Y_1 = 4\))**:
  - `lower_bound(4)` -> \(5\)
  - ใช้เรือ \(5\), ลบออก
  - เหลือ: \(\{3, 7, 10, 20\}\)
  - \(weeks = 1\)

- **สัปดาห์ 2 (\(Y_2 = 17\))**:
  - `lower_bound(17)` -> \(20\)
  - ใช้เรือ \(20\), ลบออก
  - เหลือ: \(\{3, 7, 10\}\)
  - \(weeks = 2\)

- **สัปดาห์ 3 (\(Y_3 = 9\))**:
  - `lower_bound(9)` -> \(10\)
  - ใช้เรือ \(10\), ลบออก
  - เหลือ: \(\{3, 7\}\)
  - \(weeks = 3\)

- **สัปดาห์ 4 (\(Y_4 = 50\))**:
  - `lower_bound(50)` -> ไม่พบ (เกิน \(7\))
  - หยุด
  - \(weeks = 3\)

**Output:**
```
3
```

### ความซับซ้อน
- **เวลา**: \(O(N \log N + M \log N)\)
  - การใส่เรือใน `multiset`: \(O(N \log N)\)
  - การวนลูป \(M\) รอบ โดยในแต่ละรอบใช้ `lower_bound` (\(O(\log N)\)): \(O(M \log N)\)
- **พื้นที่**: \(O(N + M)\) (สำหรับเก็บข้อมูลเรือและความต้องการ)

โค้ดนี้สามารถจัดการกับข้อจำกัดของโจทย์ได้ดี (\(N \leq 200,000\), \(X_i, Y_j \leq 10^9\)) และให้ผลลัพธ์ที่ถูกต้องตามตัวอย่างที่ให้มา