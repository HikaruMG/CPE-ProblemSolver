### คำอธิบายโจทย์

โจทย์นี้ให้เราสร้างโปรแกรมในภาษา C++ เพื่อตอบคำถามเกี่ยวกับการเข้าแถวของนักเรียนที่มีความสูงกำหนดไว้ โดยมีนักเรียน N คน (1 ≤ N ≤ 200,000) ยืนเรียงแถวกันอยู่แล้ว และแต่ละคนมีความสูง H_i (0 ≤ H_i ≤ 1,000,000,000) เราต้องตอบคำถาม Q ข้อ (1 ≤ Q ≤ 100,000) ซึ่งแบ่งเป็น 2 แบบ:

#### **คำถามแบบที่ 1**
- **คำถาม:** ถ้าเราต้องการเข้าแถวต่อจากนักเรียนคนที่ j (ตำแหน่ง j+1) ความสูงสูงสุดที่เราจะมีได้คือเท่าไหร่ โดยที่เมื่อนับจากคนที่ 1 ถึงตำแหน่งของเรา (ตำแหน่ง j+1) เราเป็นคนที่เตี้ยที่สุด (อาจมีคนอื่นสูงเท่าเราได้)
- **ความหมาย:** ความสูงของเราต้องไม่เกินค่าต่ำสุดของความสูงตั้งแต่คนที่ 1 ถึงคนที่ j (min(H_1, H_2, ..., H_j)) เพราะถ้าสูงกว่านี้ เราจะไม่ใช่คนที่เตี้ยที่สุดในกลุ่มนั้น
- **คำตอบ:** min(H_1, H_2, ..., H_j)

#### **คำถามแบบที่ 2**
- **คำถาม:** ถ้าเรามีความสูง k เราจะเข้าแถวต่อจากคนที่ j ใดได้ โดยที่ j เป็นค่ามากที่สุด (ปลายแถวที่สุด) และเรายังคงเป็นคนที่เตี้ยที่สุดเมื่อนับจากคนที่ 1 ถึงตำแหน่งของเรา (อาจมีคนอื่นสูงเท่าเราได้) ถ้าสูงกว่าคนแรก (H_1) ให้ตอบ 0
- **ความหมาย:** หา j สูงสุดที่ min(H_1, H_2, ..., H_j) ≥ k ถ้า k > H_1 จะไม่มี j ใดเลย เพราะเราจะสูงกว่าคนที่ 1
- **คำตอบ:** j สูงสุดที่ min(H_1, ..., H_j) ≥ k หรือ 0 ถ้าไม่มี

#### **ตัวอย่าง**
- N = 5, H = [100, 240, 80, 90, 75]
- คำถามและคำตอบ:
  1. T=1, j=1 → 100 (min(100) = 100)
  2. T=1, j=4 → 80 (min(100, 240, 80, 90) = 80)
  3. T=2, k=95 → 2 (min(100, 240) = 100 ≥ 95, แต่ min(100, 240, 80) = 80 < 95)
  4. T=2, k=80 → 4 (min(100, 240, 80, 90) = 80 ≥ 80, แต่ min(100, 240, 80, 90, 75) = 75 < 80)
  5. T=2, k=50 → 5 (min(100, 240, 80, 90, 75) = 75 ≥ 50)
  6. T=2, k=120 → 0 (120 > 100 = H_1)

---

### ขั้นตอนการคิดและการออกแบบโปรแกรม

เพื่อให้โปรแกรมทำงานได้อย่างมีประสิทธิภาพกับ N และ Q ที่มีขนาดใหญ่ (ถึง 200,000 และ 100,000) เราต้องออกแบบวิธีที่ใช้เวลาไม่มากเกินไป ดังนี้:

#### **1. การเตรียมข้อมูล**
- เราจะคำนวณ **prefix minimum** (ค่าต่ำสุดตั้งแต่ต้นแถวถึงตำแหน่ง i) ล่วงหน้า และเก็บไว้ในอาร์เรย์หรือเวกเตอร์ M โดย:
  - M[i] = min(H_1, H_2, ..., H_{i+1}) (ในโค้ดจะใช้ index 0-based ดังนั้น M[0] = H_1, M[1] = min(H_1, H_2), ...)
- การคำนวณ M สามารถทำได้ใน O(N) โดย:
  - M[0] = H[0]
  - M[i] = min(M[i-1], H[i]) สำหรับ i = 1 ถึง N-1

#### **2. การตอบคำถาม**
- **คำถามแบบที่ 1:**
  - เมื่อให้ j คำตอบคือ M[j-1] (เพราะ j เป็น 1-based แต่ M ใช้ 0-based)
  - ความซับซ้อน: O(1) ต่อคำถาม
- **คำถามแบบที่ 2:**
  - ต้องหา j สูงสุดที่ M[j-1] ≥ k
  - เนื่องจาก M เป็นลำดับที่ **ไม่เพิ่มขึ้น** (non-increasing) เช่น [100, 100, 80, 80, 75] เราสามารถใช้ **binary search** เพื่อหาตำแหน่งได้
  - ใช้ `upper_bound` กับ `greater<long long>` เพื่อหาตำแหน่งแรกที่ M[i] < k แล้วตำแหน่งก่อนหน้านั้นคือ j สูงสุดที่ M[i] ≥ k
  - ความซับซ้อน: O(log N) ต่อคำถาม

#### **3. การจัดการดัชนี**
- โจทย์ใช้ดัชนี 1-based (1 ถึง N) แต่ใน C++ เราใช้ 0-based (0 ถึง N-1) ดังนั้น:
  - สำหรับ T=1: อ่าน j แล้วใช้ M[j-1]
  - สำหรับ T=2: คำนวณ j จาก binary search แล้วปรับให้เป็น 1-based

#### **4. ความซับซ้อนรวม**
- เตรียม M: O(N)
- ตอบคำถาม Q ข้อ:
  - T=1: O(Q1) (Q1 = จำนวนคำถามแบบที่ 1)
  - T=2: O(Q2 * log N) (Q2 = จำนวนคำถามแบบที่ 2)
- รวม: O(N + Q * log N) ซึ่งเพียงพอกับ constraints

---

### โค้ดโปรแกรมในภาษา C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    // ปิดการซิงโครไนซ์กับ stdio เพื่อให้ I/O เร็วขึ้น
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    // อ่าน N และ Q
    long long N, Q;
    cin >> N >> Q;

    // อ่านความสูง H
    vector<long long> H(N);
    for(int i = 0; i < N; i++) {
        cin >> H[i];
    }

    // คำนวณ prefix minimum M
    vector<long long> M(N);
    M[0] = H[0];
    for(int i = 1; i < N; i++) {
        M[i] = min(M[i-1], H[i]);
    }

    // ตอบคำถาม Q ข้อ
    for(int qi = 0; qi < Q; qi++) {
        int T;
        cin >> T;
        if(T == 1) {
            // คำถามแบบที่ 1
            int j;
            cin >> j;
            cout << M[j-1] << endl; // j เป็น 1-based ดังนั้นใช้ j-1
        } else {
            // คำถามแบบที่ 2
            long long k;
            cin >> k;
            // หาตำแหน่งแรกที่ M[i] < k
            auto iter = upper_bound(M.begin(), M.end(), k, greater<long long>());
            int q = iter - M.begin(); // q = ตำแหน่งใน 0-based
            if(q == 0) {
                // ถ้า q=0 แปลว่า k > M[0] = H_1
                cout << 0 << endl;
            } else {
                // q เป็น j สูงสุด (1-based)
                cout << q << endl;
            }
        }
    }
    return 0;
}
```

---

### อธิบายโค้ดทีละส่วน

#### **1. Header และการตั้งค่า I/O**
```cpp
#include <bits/stdc++.h>
using namespace std;
```
- รวมไลบรารีทั้งหมด (เช่น `<vector>`, `<algorithm>`) เพื่อใช้งาน `vector` และ `upper_bound`

```cpp
ios::sync_with_stdio(false);
cin.tie(NULL);
```
- ปิดการซิงโครไนซ์กับ C stdio และ untie `cin` เพื่อให้การอ่าน/เขียนเร็วขึ้น จำเป็นสำหรับ N, Q ขนาดใหญ่

#### **2. อ่านข้อมูลนำเข้า**
```cpp
long long N, Q;
cin >> N >> Q;
```
- อ่านจำนวนนักเรียน (N) และจำนวนคำถาม (Q)

```cpp
vector<long long> H(N);
for(int i = 0; i < N; i++) {
    cin >> H[i];
}
```
- สร้างเวกเตอร์ H ขนาด N และอ่านความสูง H[i] (ใช้ `long long` เพราะ H_i ≤ 10^9)

#### **3. คำนวณ Prefix Minimum**
```cpp
vector<long long> M(N);
M[0] = H[0];
for(int i = 1; i < N; i++) {
    M[i] = min(M[i-1], H[i]);
}
```
- สร้างเวกเตอร์ M ขนาด N
- M[0] = H_1
- M[i] = min(M[i-1], H[i]) คำนวณค่าต่ำสุดตั้งแต่ H_0 ถึง H_i (ในโค้ด H[0] = H_1 ในโจทย์)

#### **4. ตอบคำถาม**
```cpp
for(int qi = 0; qi < Q; qi++) {
    int T;
    cin >> T;
```
- วนลูป Q ครั้ง อ่านประเภทคำถาม (T)

**คำถามแบบที่ 1:**
```cpp
if(T == 1) {
    int j;
    cin >> j;
    cout << M[j-1] << endl;
}
```
- อ่าน j (1-based)
- ตอบ M[j-1] เพราะ M[0] = min(H_1), M[1] = min(H_1, H_2), ...

**คำถามแบบที่ 2:**
```cpp
else {
    long long k;
    cin >> k;
    auto iter = upper_bound(M.begin(), M.end(), k, greater<long long>());
    int q = iter - M.begin();
    if(q == 0) {
        cout << 0 << endl;
    } else {
        cout << q << endl;
    }
}
```
- อ่าน k
- ใช้ `upper_bound` กับ `greater<long long>` หาตำแหน่งแรกที่ M[i] < k (M เป็น non-increasing)
- `q = iter - M.begin()`:
  - ถ้า q = 0: iter ชี้ที่ M.begin() แปลว่า M[0] < k หรือ k > H_1 ตอบ 0
  - ถ้า q = N: iter = M.end() แปลว่า M[N-1] ≥ k ตอบ N
  - ถ้า 0 < q < N: ตอบ q (j สูงสุดที่ M[q-1] ≥ k)

---

### ตัวอย่างการทำงาน

#### **ข้อมูลนำเข้า**
```
5 6
100
240
80
90
75
1 1
1 4
2 95
2 80
2 50
2 120
```

#### **การประมวลผล**
1. **N=5, Q=6**
2. **H = [100, 240, 80, 90, 75]**
3. **M = [100, 100, 80, 80, 75]**
   - M[0] = 100
   - M[1] = min(100, 240) = 100
   - M[2] = min(100, 80) = 80
   - M[3] = min(80, 90) = 80
   - M[4] = min(80, 75) = 75
4. **คำถาม:**
   - **T=1, j=1:** M[0] = 100 → **100**
   - **T=1, j=4:** M[3] = 80 → **80**
   - **T=2, k=95:** upper_bound หา M[i] < 95 → M[2]=80, iter = M.begin()+2, q=2 → **2**
   - **T=2, k=80:** upper_bound หา M[i] < 80 → M[4]=75, iter = M.begin()+4, q=4 → **4**
   - **T=2, k=50:** upper_bound หา M[i] < 50 → ไม่มี, iter = M.end(), q=5 → **5**
   - **T=2, k=120:** upper_bound หา M[i] < 120 → M[0]=100, iter = M.begin(), q=0 → **0**

#### **ข้อมูลส่งออก**
```
100
80
2
4
5
0
```

---

### สรุป
โปรแกรมนี้แก้ปัญหาได้ถูกต้องตามโจทย์ โดยใช้การคำนวณ prefix minimum และ binary search เพื่อให้มีประสิทธิภาพสูงสุด ด้วยความซับซ้อน O(N + Q * log N) ซึ่งเหมาะสมกับ constraints ที่กำหนด (N ≤ 200,000, Q ≤ 100,000) และให้ผลลัพธ์ตรงตามตัวอย่างที่ให้มา