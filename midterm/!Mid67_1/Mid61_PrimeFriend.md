### คำอธิบายโจทย์

โจทย์นี้ต้องการให้เรานับจำนวนคู่ของจำนวนเฉพาะที่เป็น "สหายกัน" ในช่วงที่กำหนดจาก \(L\) ถึง \(R\) โดยจำนวนเฉพาะสองจำนวน \(A\) และ \(B\) จะเป็นสหายกันถ้าผลต่าง \(|A - B| = 2\) ซึ่งหมายถึงจำนวนเฉพาะที่ห่างกัน 2 หน่วย เช่น (3,5), (5,7), (11,13), (17,19) เป็นต้น นอกจากนี้ จำนวนเฉพาะทั้งสองในคู่ต้องอยู่ในช่วง \(L\) ถึง \(R\) (รวมทั้ง \(L\) และ \(R\)) โดยที่ \(1 \leq L \leq R \leq 200,000\)

#### ข้อมูลนำเข้า
- บรรทัดเดียวประกอบด้วยจำนวนเต็มสองจำนวน \(L\) และ \(R\) ซึ่ง \(1 \leq L \leq R \leq 200,000\)

#### ข้อมูลส่งออก
- จำนวนเต็มหนึ่งจำนวนที่ระบุว่ามีคู่ของจำนวนเฉพาะที่เป็นสหายกันกี่คู่ในช่วง \(L\) ถึง \(R\)

#### ตัวอย่าง
- หาก \(L = 3\) และ \(R = 20\):
  - จำนวนเฉพาะในช่วงนี้คือ 3, 5, 7, 11, 13, 17, 19
  - คู่ที่เป็นสหายกันคือ (3,5), (5,7), (11,13), (17,19)
  - ดังนั้นผลลัพธ์คือ 4 คู่

---

### ขั้นตอนการคิด

เพื่อแก้โจทย์นี้ เราจะต้องหาวิธีที่มีประสิทธิภาพในการหาจำนวนเฉพาะในช่วง \(L\) ถึง \(R\) และนับคู่ที่ห่างกัน 2 หน่วย ขั้นตอนการออกแบบมีดังนี้:

1. **หาจำนวนเฉพาะในช่วง \(L\) ถึง \(R\)**  
   เนื่องจาก \(R\) สามารถสูงถึง 200,000 การตรวจสอบจำนวนเฉพาะทีละจำนวนด้วยวิธีทั่วไป (เช่น การหาร) จะช้าเกินไป วิธีที่มีประสิทธิภาพคือการใช้ **Sieve of Eratosthenes** เพื่อสร้างรายการจำนวนเฉพาะตั้งแต่ 1 ถึง \(R\)

2. **กรองจำนวนเฉพาะที่อยู่ในช่วง \(L\) ถึง \(R\)**  
   หลังจากได้รายการจำนวนเฉพาะทั้งหมดถึง \(R\) เราจะพิจารณาเฉพาะจำนวนที่อยู่ระหว่าง \(L\) และ \(R\) (รวมขอบเขต)

3. **นับคู่ที่เป็นสหายกัน**  
   สำหรับจำนวนเฉพาะแต่ละตัว \(p\) ในช่วง \(L\) ถึง \(R\) ตรวจสอบว่า \(p + 2\) เป็นจำนวนเฉพาะและอยู่ในช่วง \(L\) ถึง \(R\) ด้วยหรือไม่ ถ้าใช่ จะนับเป็น 1 คู่

4. **จัดการกรณีพิเศษ**  
   - ถ้า \(L = R\) จะไม่มีคู่ใด ๆ เพราะต้องมีสองจำนวนที่แตกต่างกัน
   - ต้องระวังไม่นับคู่ซ้ำ เช่น (5,7) และ (7,5) ถือเป็นคู่เดียวกัน ดังนั้นเราจะนับเฉพาะคู่ที่จำนวนแรกน้อยกว่าจำนวนที่สอง

5. **เพิ่มประสิทธิภาพ**  
   การใช้ Sieve of Eratosthenes มีความซับซ้อน \(O(R \log \log R)\) ซึ่งเพียงพอสำหรับ \(R \leq 200,000\) และการนับคู่จะมีความซับซ้อนขึ้นอยู่กับจำนวนจำนวนเฉพาะในช่วง ซึ่งไม่มากเกินไป

---

### การออกแบบโปรแกรม

เราจะเขียนโปรแกรมในภาษา C++ โดยแบ่งเป็นส่วน ๆ ดังนี้:

1. **ฟังก์ชัน Sieve**  
   สร้างฟังก์ชันที่ใช้ Sieve of Eratosthenes เพื่อหาจำนวนเฉพาะทั้งหมดถึง \(R\)

2. **การนับคู่**  
   วนลูปผ่านจำนวนในช่วง \(L\) ถึง \(R - 2\) และตรวจสอบคู่ \(i\) และ \(i + 2\)

3. **รับข้อมูลและแสดงผล**  
   รับค่า \(L\) และ \(R\) จากผู้ใช้ และแสดงจำนวนคู่ที่คำนวณได้

ต่อไปนี้เป็นโค้ดที่สมบูรณ์:

```cpp
#include <iostream>
#include <vector>
#include <cmath>

// ฟังก์ชันสร้าง Sieve เพื่อหาจำนวนเฉพาะถึง R
std::vector<bool> sieve(int R) {
    std::vector<bool> isPrime(R + 1, true); // สร้างเวกเตอร์ขนาด R+1 โดยเริ่มต้นเป็น true
    isPrime[0] = isPrime[1] = false;        // 0 และ 1 ไม่ใช่จำนวนเฉพาะ
    for (int i = 2; i <= std::sqrt(R); ++i) {
        if (isPrime[i]) {                   // ถ้า i เป็นจำนวนเฉพาะ
            for (int j = i * i; j <= R; j += i) {
                isPrime[j] = false;         // ตัดพหุคูณของ i ออก
            }
        }
    }
    return isPrime;
}

int main() {
    int L, R;
    std::cin >> L >> R;                     // รับค่า L และ R จากผู้ใช้
    
    // สร้าง Sieve ถึง R
    std::vector<bool> isPrime = sieve(R);
    
    int count = 0;                          // ตัวแปรนับจำนวนคู่
    // วนลูปตั้งแต่ L ถึง R-2 เพื่อหาคู่ที่ห่างกัน 2
    for (int i = L; i <= R - 2; ++i) {
        if (isPrime[i] && isPrime[i + 2]) { // ถ้า i และ i+2 เป็นจำนวนเฉพาะ
            count++;                        // เพิ่มจำนวนคู่
        }
    }
    
    std::cout << count << std::endl;        // แสดงผลลัพธ์
    return 0;
}
```

---

### คำอธิบายโค้ดทีละส่วน

#### 1. **ส่วนหัวไฟล์**
```cpp
#include <iostream>
#include <vector>
#include <cmath>
```
- `<iostream>`: ใช้สำหรับรับข้อมูลเข้าและแสดงผลลัพธ์
- `<vector>`: ใช้สำหรับสร้าง `std::vector` เพื่อเก็บข้อมูลว่าเป็นจำนวนเฉพาะหรือไม่
- `<cmath>`: ใช้ฟังก์ชัน `std::sqrt` เพื่อคำนวณรากที่สองใน Sieve

#### 2. **ฟังก์ชัน `sieve`**
```cpp
std::vector<bool> sieve(int R) {
    std::vector<bool> isPrime(R + 1, true);
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i <= std::sqrt(R); ++i) {
        if (isPrime[i]) {
            for (int j = i * i; j <= R; j += i) {
                isPrime[j] = false;
            }
        }
    }
    return isPrime;
}
```
- **วัตถุประสงค์**: สร้างเวกเตอร์ `isPrime` ที่ระบุว่าแต่ละจำนวนตั้งแต่ 0 ถึง \(R\) เป็นจำนวนเฉพาะหรือไม่
- **การทำงาน**:
  - สร้าง `std::vector<bool>` ขนาด \(R + 1\) โดยตั้งค่าเริ่มต้นเป็น `true` (สมมติว่าทุกจำนวนเป็นจำนวนเฉพาะ)
  - ตั้งค่า `isPrime[0]` และ `isPrime[1]` เป็น `false` เพราะ 0 และ 1 ไม่ใช่จำนวนเฉพาะ
  - วนลูปตั้งแต่ \(i = 2\) ถึง \(\sqrt{R}\) (รากที่สองของ \(R\)) เพื่อหาจำนวนเฉพาะ
  - ถ้า \(i\) เป็นจำนวนเฉพาะ (คือ `isPrime[i] = true`) ให้ตัดพหุคูณของ \(i\) ออกโดยตั้งค่า `isPrime[j] = false` สำหรับ \(j = i^2, i^2 + i, i^2 + 2i, ...\) จนถึง \(R\)
  - คืนค่าเวกเตอร์ `isPrime`

#### 3. **ฟังก์ชัน `main`**
```cpp
int main() {
    int L, R;
    std::cin >> L >> R;
    std::vector<bool> isPrime = sieve(R);
    int count = 0;
    for (int i = L; i <= R - 2; ++i) {
        if (isPrime[i] && isPrime[i + 2]) {
            count++;
        }
    }
    std::cout << count << std::endl;
    return 0;
}
```
- **รับข้อมูล**:
  - ใช้ `std::cin` เพื่อรับค่า \(L\) และ \(R\) จากผู้ใช้
- **สร้าง Sieve**:
  - เรียก `sieve(R)` เพื่อสร้างเวกเตอร์ `isPrime` ที่บอกว่าจำนวนถึง \(R\) เป็นจำนวนเฉพาะหรือไม่
- **นับคู่**:
  - ใช้ตัวแปร `count` เพื่อนับจำนวนคู่
  - วนลูปตั้งแต่ \(i = L\) ถึง \(R - 2\) (หยุดที่ \(R - 2\) เพราะถ้า \(i > R - 2\) แล้ว \(i + 2\) จะเกิน \(R\))
  - ตรวจสอบว่า \(i\) และ \(i + 2\) เป็นจำนวนเฉพาะหรือไม่โดยใช้ `isPrime[i]` และ `isPrime[i + 2]`
  - ถ้าทั้งคู่เป็นจำนวนเฉพาะ เพิ่มค่า `count` ขึ้น 1
- **แสดงผล**:
  - ใช้ `std::cout` เพื่อแสดงค่า `count` และขึ้นบรรทัดใหม่ด้วย `std::endl`

---

### ตัวอย่างการทำงาน

#### ตัวอย่าง 1: \(L = 3, R = 20\)
- **ขั้นตอน**:
  - สร้าง Sieve ถึง 20: จำนวนเฉพาะคือ 2, 3, 5, 7, 11, 13, 17, 19
  - กรองในช่วง 3 ถึง 20: ได้ 3, 5, 7, 11, 13, 17, 19
  - วนลูปตั้งแต่ \(i = 3\) ถึง \(18\) (เพราะ \(20 - 2 = 18\)):
    - \(i = 3\): \(3\) และ \(5\) เป็นจำนวนเฉพาะ → นับ 1 คู่ (3,5)
    - \(i = 5\): \(5\) และ \(7\) เป็นจำนวนเฉพาะ → นับ 1 คู่ (5,7)
    - \(i = 6\): \(6\) ไม่ใช่จำนวนเฉพาะ → ข้าม
    - \(i = 7\): \(7\) และ \(9\) (\(9\) ไม่ใช่จำนวนเฉพาะ) → ข้าม
    - \(i = 11\): \(11\) และ \(13\) เป็นจำนวนเฉพาะ → นับ 1 คู่ (11,13)
    - \(i = 13\): \(13\) และ \(15\) (\(15\) ไม่ใช่จำนวนเฉพาะ) → ข้าม
    - \(i = 17\): \(17\) และ \(19\) เป็นจำนวนเฉพาะ → นับ 1 คู่ (17,19)
    - \(i = 18\): \(18\) ไม่ใช่จำนวนเฉพาะ → ข้าม
  - รวม: ได้ 4 คู่
- **ผลลัพธ์**: 4

#### ตัวอย่าง 2: \(L = 5, R = 7\)
- **ขั้นตอน**:
  - Sieve ถึง 7: จำนวนเฉพาะคือ 2, 3, 5, 7
  - กรองในช่วง 5 ถึง 7: ได้ 5, 7
  - วนลูปตั้งแต่ \(i = 5\) ถึง \(5\) (เพราะ \(7 - 2 = 5\)):
    - \(i = 5\): \(5\) และ \(7\) เป็นจำนวนเฉพาะ → นับ 1 คู่ (5,7)
  - รวม: ได้ 1 คู่
- **ผลลัพธ์**: 1

#### ตัวอย่าง 3: \(L = 2, R = 3\)
- **ขั้นตอน**:
  - Sieve ถึง 3: จำนวนเฉพาะคือ 2, 3
  - กรองในช่วง 2 ถึง 3: ได้ 2, 3
  - วนลูปตั้งแต่ \(i = 2\) ถึง \(1\) (เพราะ \(3 - 2 = 1\)) → ลูปไม่ทำงาน
  - ไม่มีคู่ใดห่างกัน 2 และอยู่ในช่วง
- **ผลลัพธ์**: 0

---

### การวิเคราะห์ประสิทธิภาพ
- **Sieve of Eratosthenes**: ความซับซ้อน \(O(R \log \log R)\) ซึ่งสำหรับ \(R = 200,000\) ทำงานได้เร็วมาก
- **การนับคู่**: ความซับซ้อน \(O(R - L)\) ซึ่งในกรณีที่เลวร้ายที่สุดคือ \(O(200,000)\) ยังคงมีประสิทธิภาพ
- **หน่วยความจำ**: ใช้ `vector<bool>` ขนาด \(R + 1\) ซึ่งประหยัดหน่วยความจำ (ประมาณ 200,000 bits หรือ 25 KB)

โค้ดนี้จึงเหมาะสมและมีประสิทธิภาพสำหรับโจทย์นี้ และสามารถจัดการกับทุกกรณีตามที่ระบุในโจทย์ได้อย่างถูกต้อง