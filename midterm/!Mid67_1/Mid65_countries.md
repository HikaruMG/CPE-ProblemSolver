ด้านล่างนี้เป็นแนวทางการแก้โจทย์ด้วยภาษา C++ พร้อมทั้งคำอธิบายแนวคิดและรายละเอียดของแต่ละส่วนของโค้ด พร้อมตัวอย่างการทำงาน

---

## แนวคิดและขั้นตอนการแก้โจทย์

1. **อ่านข้อมูลและเก็บแผนที่:**  
   รับจำนวนแถว \(R\) และคอลัมน์ \(C\) พร้อมกับตำแหน่งเริ่มต้น \((A,B)\) และตำแหน่งปลายทาง \((X,Y)\) จากนั้นรับข้อมูลแผนที่ในรูปแบบตารางที่แต่ละช่องมีตัวเลขบอกประเทศที่ช่องนั้นอยู่

2. **ดึงหมายเลขประเทศของจุดเริ่มต้นและปลายทาง:**  
   - ใช้ข้อมูลแผนที่ที่เก็บไว้เพื่อตรวจสอบว่าช่องที่ \((A,B)\) อยู่ในประเทศอะไร (เรียกว่า `startCountry`)
   - ตรวจสอบว่าช่องที่ \((X,Y)\) อยู่ในประเทศอะไร (เรียกว่า `targetCountry`)  
   **หมายเหตุ:** ถ้าเริ่มต้นและปลายทางอยู่ในประเทศเดียวกันก็ไม่ต้องขอวีซ่า (ผลลัพธ์ 0)

3. **สร้างกราฟของประเทศ:**  
   เพราะการเดินทางภายในประเทศเดียวกันไม่ต้องใช้วีซ่า เราจึงสนใจเฉพาะการ “ข้าม” จากประเทศหนึ่งไปอีกประเทศหนึ่ง  
   - ทำการวนซ้ำทุกช่องในตารางและตรวจสอบเพื่อนบ้าน 4 ทิศ (บน, ล่าง, ซ้าย, ขวา)
   - ถ้าช่องเพื่อนบ้านมีประเทศที่แตกต่างกัน ให้เพิ่มขอบเชื่อมระหว่างประเทศนั้นๆ (ใช้ `set` เพื่อลดการซ้ำของขอบเชื่อม)

4. **ค้นหาจำนวนวีซ่าที่น้อยที่สุดโดยใช้ BFS บนกราฟประเทศ:**  
   - กำหนดค่าเริ่มต้นของประเทศที่เริ่มต้นเป็น 0 (ไม่ต้องขอวีซ่า)
   - ใช้ BFS จากประเทศเริ่มต้น เมื่อข้ามไปประเทศใหม่ ค่าวีซ่าจะเพิ่มขึ้นทีละ 1  
   - เมื่อถึงประเทศของจุดปลายทาง จะได้จำนวนวีซ่าอย่างน้อยสุด

---

## โค้ดตัวอย่าง (C++)

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <set>
using namespace std;

int main(){
    // อ่านข้อมูลอินพุต
    int R, C, A, B, X, Y;
    cin >> R >> C >> A >> B >> X >> Y;
    
    // อ่านแผนที่และเก็บใน vector 2 มิติ
    vector<vector<int>> grid(R, vector<int>(C));
    for (int i = 0; i < R; i++){
        for (int j = 0; j < C; j++){
            cin >> grid[i][j];
        }
    }
    
    // หารหัสประเทศของจุดเริ่มต้นและจุดปลายทาง
    int startCountry = grid[A - 1][B - 1];  // ปรับจาก 1-based เป็น 0-based
    int targetCountry = grid[X - 1][Y - 1];
    
    // ถ้าเริ่มต้นและปลายทางอยู่ในประเทศเดียวกัน ไม่ต้องขอวีซ่า
    if(startCountry == targetCountry){
        cout << 0 << endl;
        return 0;
    }
    
    // สร้างกราฟของประเทศ
    // เนื่องจากรหัสประเทศมีค่าสูงสุดไม่เกิน R*C เราจึงใช้ vector<set<int>> เพื่อเก็บเพื่อนบ้านของแต่ละประเทศ
    int maxCountry = R * C;
    vector<set<int>> graph(maxCountry + 1);
    
    // กำหนดทิศที่สามารถเดินได้ 4 ทิศ: ขึ้น, ลง, ซ้าย, ขวา
    int dx[4] = {-1, 1, 0, 0};
    int dy[4] = {0, 0, -1, 1};
    
    // วนซ้ำทุกช่องเพื่อตรวจสอบเพื่อนบ้าน
    for (int i = 0; i < R; i++){
        for (int j = 0; j < C; j++){
            int curr = grid[i][j];
            for (int k = 0; k < 4; k++){
                int ni = i + dx[k], nj = j + dy[k];
                // ตรวจสอบว่าอยู่ในขอบเขตของแผนที่หรือไม่
                if(ni >= 0 && ni < R && nj >= 0 && nj < C){
                    int neighbor = grid[ni][nj];
                    // ถ้าเพื่อนบ้านอยู่ในประเทศที่แตกต่างกันให้เพิ่มขอบเชื่อม
                    if(neighbor != curr){
                        graph[curr].insert(neighbor);
                    }
                }
            }
        }
    }
    
    // ใช้ BFS ในการค้นหาจำนวนวีซ่า (คือจำนวนการข้ามประเทศ)
    // visa[i] เก็บจำนวนวีซ่าที่ต้องใช้ในการไปถึงประเทศ i
    vector<int> visa(maxCountry + 1, -1);
    queue<int> q;
    visa[startCountry] = 0; // ไม่ต้องขอวีซ่าสำหรับประเทศเริ่มต้น
    q.push(startCountry);
    
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        // ตรวจสอบเพื่อนบ้านของประเทศ cur
        for(auto nxt : graph[cur]){
            if(visa[nxt] == -1){ // ถ้ายังไม่เข้าเยี่ยมประเทศนี้
                visa[nxt] = visa[cur] + 1;
                // ถ้าเป็นประเทศปลายทางก็แสดงผลและจบโปรแกรม
                if(nxt == targetCountry){
                    cout << visa[nxt] << endl;
                    return 0;
                }
                q.push(nxt);
            }
        }
    }
    
    // กรณีที่ไม่สามารถเดินทางไปถึง (ตามโจทย์รับประกันว่ามีเส้นทางเดิน)
    cout << visa[targetCountry] << endl;
    return 0;
}
```

---

## คำอธิบายโค้ดทีละส่วน

1. **การรับอินพุตและเก็บแผนที่:**  
   ```cpp
   int R, C, A, B, X, Y;
   cin >> R >> C >> A >> B >> X >> Y;
   vector<vector<int>> grid(R, vector<int>(C));
   for (int i = 0; i < R; i++){
       for (int j = 0; j < C; j++){
           cin >> grid[i][j];
       }
   }
   ```  
   - โค้ดส่วนนี้อ่านข้อมูลจากอินพุตและเก็บข้อมูลแผนที่ลงในตัวแปร `grid`  
   - ปรับตำแหน่งจาก 1-based เป็น 0-based เมื่อใช้อ้างอิงข้อมูลใน `grid`

2. **การดึงหมายเลขประเทศของจุดเริ่มต้นและปลายทาง:**  
   ```cpp
   int startCountry = grid[A - 1][B - 1];
   int targetCountry = grid[X - 1][Y - 1];
   if(startCountry == targetCountry){
       cout << 0 << endl;
       return 0;
   }
   ```  
   - ดึงประเทศของช่องเริ่มต้นและช่องปลายทาง  
   - ตรวจสอบว่าหากอยู่ในประเทศเดียวกันก็แสดงผลเป็น 0 และจบโปรแกรม

3. **การสร้างกราฟของประเทศ:**  
   ```cpp
   int maxCountry = R * C;
   vector<set<int>> graph(maxCountry + 1);
   int dx[4] = {-1, 1, 0, 0};
   int dy[4] = {0, 0, -1, 1};
   for (int i = 0; i < R; i++){
       for (int j = 0; j < C; j++){
           int curr = grid[i][j];
           for (int k = 0; k < 4; k++){
               int ni = i + dx[k], nj = j + dy[k];
               if(ni >= 0 && ni < R && nj >= 0 && nj < C){
                   int neighbor = grid[ni][nj];
                   if(neighbor != curr){
                       graph[curr].insert(neighbor);
                   }
               }
           }
       }
   }
   ```  
   - ใช้ลูปเช็คทุกช่องและเพื่อนบ้าน 4 ทิศ  
   - ถ้าเพื่อนบ้านอยู่ในประเทศที่แตกต่างกัน จะเพิ่มประเทศนั้นลงใน set ของ `graph[curr]`  
   - การใช้ `set` ช่วยให้ไม่มีการเพิ่มซ้ำของขอบเชื่อม

4. **การใช้ BFS ค้นหาเส้นทางที่มีวีซ่าน้อยที่สุด:**  
   ```cpp
   vector<int> visa(maxCountry + 1, -1);
   queue<int> q;
   visa[startCountry] = 0;
   q.push(startCountry);
   
   while(!q.empty()){
       int cur = q.front();
       q.pop();
       for(auto nxt : graph[cur]){
           if(visa[nxt] == -1){
               visa[nxt] = visa[cur] + 1;
               if(nxt == targetCountry){
                   cout << visa[nxt] << endl;
                   return 0;
               }
               q.push(nxt);
           }
       }
   }
   ```  
   - เราใช้อาเรย์ `visa` เก็บจำนวนวีซ่าที่ต้องใช้เพื่อเข้าถึงแต่ละประเทศ  
   - เริ่มจากประเทศเริ่มต้น (ค่า 0) แล้วทำการขยายไปยังประเทศเพื่อนบ้าน  
   - เมื่อไปถึง `targetCountry` จะแสดงผลจำนวนวีซ่าแล้วจบโปรแกรม

---

## ตัวอย่างการทำงาน

### ตัวอย่างที่ 1

**อินพุต:**  
```
5 8 1 1 1 5
1 1 2 2 2 3 3 3 
1 4 2 2 2 3 3 3 
4 4 2 2 2 5 6 3 
4 4 4 4 5 5 6 6 
4 4 5 5 5 6 6 6
```

**อธิบาย:**  
- จุดเริ่มต้น (1,1) อยู่ในประเทศ 1  
- จุดปลายทาง (1,5) อยู่ในประเทศ 2  
- พบว่าประเทศ 1 และประเทศ 2 มีขอบติดกัน (เนื่องจากช่อง (1,1) อยู่ติดกับช่อง (1,3) ที่เป็นประเทศ 2)  
- ดังนั้น การเดินทางจากประเทศ 1 ไปประเทศ 2 มีค่าใช้จ่ายวีซ่า 1

**ผลลัพธ์:**  
```
1
```

### ตัวอย่างที่ 2

**อินพุต:**  
```
4 5 1 2 4 3
1 2 3 4 5 
6 7 8 9 10 
11 12 13 14 15 
16 17 18 19 20
```

**อธิบาย:**  
- จุดเริ่มต้น (1,2) อยู่ในประเทศ 2  
- จุดปลายทาง (4,3) อยู่ในประเทศ 18  
- ในแผนที่แต่ละช่องเป็นประเทศที่แตกต่างกัน ดังนั้นต้องข้ามประเทศทีละช่องตามการเชื่อมกัน  
- ผลลัพธ์คือจำนวนวีซ่า 4 (เส้นทางที่ดีที่สุดอาจต้องข้ามประเทศ 4 ครั้ง)

**ผลลัพธ์:**  
```
4
```

### ตัวอย่างที่ 3

**อินพุต:**  
```
5 8 1 1 5 7
1 1 2 2 2 3 3 3 
1 4 2 2 2 3 3 3 
4 4 2 2 2 5 6 3 
4 4 4 4 5 5 6 6 
4 4 5 5 5 6 6 6
```

**อธิบาย:**  
- จุดเริ่มต้น (1,1) อยู่ในประเทศ 1  
- จุดปลายทาง (5,7) อยู่ในประเทศ 6  
- ตามการเชื่อมของประเทศในแผนที่ การเดินทางจากประเทศ 1 ไปประเทศ 6 ที่ใช้วีซ่าน้อยที่สุดคือ 3 ครั้ง

**ผลลัพธ์:**  
```
3
```

---

โดยสรุป โค้ดนี้จะสร้างกราฟของประเทศจากแผนที่ที่ได้รับและใช้เทคนิค BFS ในการหาจำนวนการข้ามประเทศที่น้อยที่สุด ซึ่งเท่ากับจำนวนวีซ่าที่ต้องขอ (ยกเว้นประเทศเริ่มต้น) หวังว่าคำอธิบายและตัวอย่างนี้จะช่วยให้เข้าใจแนวทางการแก้โจทย์ได้อย่างชัดเจนครับ