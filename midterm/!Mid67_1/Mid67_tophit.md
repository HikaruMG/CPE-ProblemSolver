ด้านล่างนี้เป็นแนวทางแก้ปัญหาโดยใช้เทคนิค **Sliding Window** ควบคู่กับโครงสร้างข้อมูล (เช่น std::set) ที่สามารถอัปเดตอันดับของหนังสือในหน้าต่างได้แบบไดนามิก

---

### แนวคิดและขั้นตอนแก้ปัญหา

1. **ปัญหา:**  
   ให้มีการโหวตเข้ามาทั้งหมด N ครั้ง โดยหนังสือแต่ละเล่มมีหมายเลขอยู่ในช่วง 1 ถึง L  
   เมื่อมีการโหวตเข้ามา ทางสำนักพิมพ์ต้องการแสดง “ผลลัพธ์” โดยคำนวณจาก **M โหวตล่าสุด** (คือในแต่ละช่วงของ M โหวตที่ต่อเนื่องกัน) ว่าในช่วงนั้นหนังสือเล่มไหนได้รับโหวตมากที่สุด (ถ้าเท่ากันให้เลือกเล่มที่มีหมายเลขน้อยกว่า)  
   จากนั้น ให้หาว่าในช่วงเวลาต่างๆ ที่มีการแสดงผล (คือทุกครั้งที่มีหน้าต่างขนาด M) ผลลัพธ์ที่แสดงออกมามีคะแนนสูงสุด (คือจำนวนโหวตในหน้าต่างนั้น) เมื่อมีหลายช่วงที่ได้คะแนนสูงเท่ากัน ให้เลือกหนังสือที่มีหมายเลขน้อยที่สุด

2. **การทำงาน:**  
   - ใช้ **Sliding Window** ขนาด M เพื่อนับคะแนนในช่วงล่าสุดที่เข้ามา  
   - ใช้ `unordered_map<int,int>` เก็บจำนวนโหวตของหนังสือแต่ละเล่มในหน้าต่างปัจจุบัน  
   - ใช้ `set` (หรือ multiset) พร้อม comparator แบบกำหนดเองในการเก็บคู่ข้อมูล `(frequency, book_id)` โดยให้เรียงจากคะแนนสูงไปต่ำ และถ้าคะแนนเท่ากันให้เรียงจากหมายเลขเล็กไปใหญ่  
   - เมื่อมีการเพิ่มโหวตใหม่ เข้าไปในหน้าต่าง ให้ปรับปรุงข้อมูลใน map และ set โดยเอาค่าที่เคยมีออกแล้วเพิ่มค่าที่อัปเดตใหม่  
   - เมื่อหน้าต่างมีขนาดเกิน M ให้เอาโหวตเก่าออก (คือเอาโหวตที่อยู่ด้านซ้ายสุดออก) พร้อมกับอัปเดตข้อมูลใน map และ set  
   - สำหรับแต่ละหน้าต่าง (เมื่อหน้าต่างมีขนาด M แล้ว) ให้ดู “ผู้ชนะ” (คือหนังสือที่อยู่หัว set) และบันทึกผลถ้าคะแนนในหน้าต่างนั้นมากกว่า (หรือเท่ากันแต่มีหมายเลขหนังสือเล็กกว่า) กับผลที่เคยบันทึกไว้

3. **ตัวอย่างการทำงาน (จากข้อมูลตัวอย่าง):**  
   - **Input:**  
     ```
     10 5 20
     1 
     1 
     2 
     1 
     2 
     3 
     4 
     4 
     3 
     4
     ```  
   - **ขั้นตอน:**  
     - เมื่อหน้าต่างแรก (โหวตที่ 1-5) จะได้คะแนน  
       - หนังสือ 1: 3 ครั้ง  
       - หนังสือ 2: 2 ครั้ง  
       → ผลลัพธ์ในช่วงนี้คือหนังสือ 1 ด้วยคะแนน 3  
     - เมื่อเลื่อนหน้าต่างไปทีละขั้น (ช่วงโหวต 2-6, 3-7, ... , 6-10) จะพบว่าช่วงสุดท้าย (โหวตที่ 6-10) ผลลัพธ์คือหนังสือ 4 ได้ 3 โหวต  
     - แต่เนื่องจากมีสองช่วงที่ได้คะแนนสูงสุด (3 โหวต) คือช่วงแรกที่ได้หนังสือ 1 กับช่วงสุดท้ายที่ได้หนังสือ 4 เมื่อเปรียบเทียบหมายเลขหนังสือ (1 กับ 4) เลือกเล่มที่หมายเลขน้อยกว่า  
       → **คำตอบ:** หนังสือ 1 ได้ 3 โหวต

---

### โค้ดตัวอย่างภาษา C++

```cpp
#include <iostream>
#include <unordered_map>
#include <set>
using namespace std;

// Comparator สำหรับ set เพื่อให้เรียงตามคะแนนจากมากไปน้อย
// ถ้าคะแนนเท่ากัน ให้เรียงตามหมายเลขหนังสือจากน้อยไปมาก
struct cmp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if(a.first != b.first)
            return a.first > b.first; // มากก่อน
        return a.second < b.second;   // ถ้าคะแนนเท่ากัน เล็กก่อน
    }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M, L;
    cin >> N >> M >> L;

    // Map สำหรับเก็บคะแนนในหน้าต่างปัจจุบัน
    unordered_map<int, int> freq;
    // set สำหรับจัดอันดับหนังสือในหน้าต่างปัจจุบัน
    set<pair<int, int>, cmp> ranking;

    // สำหรับเก็บคำตอบสุดท้าย
    int bestBook = 0, bestVotes = -1;

    int vote;
    // Array สำหรับเก็บข้อมูลโหวต เพื่อให้สามารถลบออกได้ตามตำแหน่ง
    int* votes = new int[N];
    
    for (int i = 0; i < N; i++){
        cin >> votes[i];
    }
    
    for (int i = 0; i < N; i++){
        int book = votes[i];
        // หากหนังสือมีอยู่ใน map อยู่แล้ว ให้เอาคู่เดิมออกจาก ranking
        if(freq.count(book)){
            ranking.erase({freq[book], book});
        }
        // เพิ่มจำนวนโหวตของหนังสือเล่มนั้น
        freq[book]++;
        // ใส่คู่ข้อมูลใหม่เข้า ranking
        ranking.insert({freq[book], book});
        
        // เมื่อหน้าต่างมีขนาดเกิน M ให้ลบโหวตที่อยู่ด้านซ้ายสุดออก
        if(i >= M){
            int outBook = votes[i - M];
            ranking.erase({freq[outBook], outBook});
            freq[outBook]--;
            // หากจำนวนโหวตยังคงเหลือ ให้เพิ่มกลับเข้าไปใน ranking
            if(freq[outBook] > 0)
                ranking.insert({freq[outBook], outBook});
        }
        
        // เมื่อมีหน้าต่างครบ M โหวตแล้ว (เริ่ม i = M-1)
        if(i >= M - 1){
            // Candidate คือหนังสือที่อยู่หัว ranking (มีคะแนนสูงสุดและถ้าคะแนนเท่ากัน เล็กสุด)
            auto candidate = *ranking.begin();
            int curVotes = candidate.first;
            int curBook = candidate.second;
            // บันทึกผลถ้าคะแนนในหน้าต่างนี้สูงกว่า หรือเท่ากันแต่หมายเลขหนังสือเล็กกว่า
            if(curVotes > bestVotes || (curVotes == bestVotes && curBook < bestBook)){
                bestVotes = curVotes;
                bestBook = curBook;
            }
        }
    }
    
    cout << bestBook << " " << bestVotes << "\n";
    
    delete[] votes;
    return 0;
}
```

---

### คำอธิบายโค้ดโดยละเอียด

1. **การเตรียมข้อมูลและโครงสร้าง:**  
   - รับค่า `N, M, L`  
   - สร้าง `unordered_map` ชื่อ `freq` เพื่อเก็บจำนวนโหวตในหน้าต่างปัจจุบัน  
   - สร้าง `set` ชื่อ `ranking` พร้อม comparator แบบกำหนดเองเพื่อเรียงคู่ข้อมูล `(คะแนน, หมายเลขหนังสือ)` โดยให้คะแนนสูงสุดมาก่อน และหากคะแนนเท่ากันให้หมายเลขเล็กก่อน

2. **ขั้นตอนการทำ Sliding Window:**  
   - อ่านโหวตทั้งหมดเก็บใน array `votes`  
   - สำหรับแต่ละโหวตที่เข้ามา (index i):
     - นำหนังสือที่ได้โหวตมาอัปเดตใน map และ set โดยถ้ามีข้อมูลเก่าอยู่ให้นำออกก่อนแล้วค่อยอัปเดตใหม่
     - เมื่อขนาดหน้าต่างเกิน M (i >= M) ให้นำโหวตที่อยู่ด้านซ้ายสุด (index i-M) ออกจาก map และ set
     - เมื่อหน้าต่างมีครบ M โหวต (i >= M-1) ให้นำคู่แรกจาก set (คือ candidate ในหน้าต่างนั้น) มาเปรียบเทียบกับผลคำตอบที่ดีที่สุดที่เคยบันทึกไว้

3. **การเปรียบเทียบและเก็บคำตอบ:**  
   - เปรียบเทียบคะแนนในแต่ละหน้าต่างที่ candidate ได้รับ หากคะแนนสูงกว่าคำตอบที่บันทึกไว้ หรือคะแนนเท่ากันแต่หมายเลขหนังสือเล็กกว่า ก็อัปเดตผลลัพธ์

4. **ตัวอย่างการทำงาน:**  
   - **ในช่วงโหวตที่ 1-5:**  
     หนังสือ 1 ได้ 3 ครั้ง, หนังสือ 2 ได้ 2 ครั้ง → candidate คือหนังสือ 1 ด้วย 3 โหวต  
   - **ในช่วงโหวตที่ 6-10:**  
     candidate ที่ได้จะเป็นหนังสือ 4 ด้วย 3 โหวตในช่วงสุดท้าย  
   - เนื่องจากมี candidate ที่มีคะแนน 3 สองครั้ง แต่เปรียบเทียบหมายเลขหนังสือแล้ว เลือกหนังสือ 1 (หมายเลขน้อยกว่า)  
   - **Output:** 1 3

---

ด้วยแนวทางนี้ โปรแกรมจะสามารถคำนวณและแสดงหนังสือที่ได้รับคะแนนสูงสุด (โดยคิดจาก M โหวตล่าสุด) พร้อมทั้งคะแนนที่ได้รับตามเงื่อนไขที่โจทย์กำหนดได้อย่างถูกต้องและมีประสิทธิภาพ

