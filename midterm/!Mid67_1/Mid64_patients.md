### คำอธิบายโจทย์

โจทย์นี้ต้องการให้เราคำนวณจำนวนผู้ป่วยที่ยังป่วยอยู่ในแต่ละวันเวลา 12:00 น. โดยมีข้อมูลดังนี้:

- **ทุกวันเวลา 8:00 น.** เราจะทราบว่ามีคนป่วยใหม่กี่กลุ่ม (L) และในแต่ละกลุ่มมีจำนวนคนป่วย (Aj) และจำนวนวันที่ป่วย (Bj)
- **กฎการหายป่วย**: ถ้าคนเริ่มป่วยในวันที่ x และป่วยเป็นเวลา y วัน เขาจะหายป่วยในเวลา 8:00 น. ของวันที่ x + y
- **การนับเวลา 12:00 น.**: 
  - ผู้ป่วยที่เริ่มป่วยในวันที่ i จะเริ่มถูกนับตั้งแต่วันที่ i เวลา 12:00 น. เป็นต้นไป
  - ผู้ป่วยที่หายป่วยในวันที่ k เวลา 8:00 น. จะไม่ถูกนับในวันที่ k เวลา 12:00 น.
- **เป้าหมาย**: คำนวณและพิมพ์จำนวนผู้ป่วยที่ยังป่วยอยู่ที่เวลา 12:00 น. ของทุกวัน ตั้งแต่วันที่ 1 ถึงวันที่ N

#### ตัวอย่างจากโจทย์
- **วันที่ 1**: พบ 10 คนป่วย 2 วัน (หายวันที่ 3), 10 คนป่วย 5 วัน (หายวันที่ 6)
- **วันที่ 2**: พบ 5 คนป่วย 1 วัน (หายวันที่ 3), 4 คนป่วย 3 วัน (หายวันที่ 5)
- **วันที่ 4**: พบ 3 คนป่วย 10 วัน (หายวันที่ 14)
- **วันที่ 3, 5-8**: ไม่มีคนป่วยใหม่

เราต้องคำนวณจำนวนคนป่วยที่เวลา 12:00 น. ของวันที่ 1 ถึง 8

### ขั้นตอนการคิด

เพื่อแก้โจทย์นี้ เราจะใช้แนวคิดดังนี้:

1. **ติดตามจำนวนคนป่วยและการหายป่วย**:
   - ใช้ตัวแปร `current` เพื่อเก็บจำนวนคนที่ยังป่วยอยู่ในขณะนั้น
   - ใช้ array หรือ vector ชื่อ `heal` เพื่อบันทึกจำนวนคนที่หายป่วยในแต่ละวันเวลา 8:00 น.

2. **ลำดับเหตุการณ์ในแต่ละวัน**:
   - **ก่อน 12:00 น.**: ลบจำนวนคนที่หายป่วยในวันนั้น (heal[i]) ออกจาก `current` เพราะคนที่หายเวลา 8:00 น. จะไม่ถูกนับที่ 12:00 น.
   - **เวลา 12:00 น.**: บวกจำนวนคนป่วยใหม่ที่พบในวันนั้นเข้าไปใน `current` และพิมพ์ค่า `current`
   - **หลัง 12:00 น.**: อัปเดต `heal` โดยเพิ่มจำนวนคนป่วยใหม่ที่พบในวันนั้นไปยังวันที่พวกเขาจะหายป่วย (i + Bj)

3. **การจัดการข้อมูล**:
   - สร้าง `heal` ให้มีขนาดใหญ่กว่า N เล็กน้อย (เช่น N + 25) เพื่อรองรับกรณีที่คนป่วยเกินวันที่ N แต่เราไม่จำเป็นต้องคำนวณเกิน N
   - อ่านข้อมูลวันละวัน และประมวลผลทันที

4. **ตัวอย่างการคำนวณ**:
   - **วันที่ 1**:
     - หายป่วย: 0 (heal[1] = 0)
     - ป่วยใหม่: 10 (2 วัน) + 10 (5 วัน) = 20
     - current = 0 - 0 + 20 = 20
     - heal[3] += 10, heal[6] += 10
     - พิมพ์ 20
   - **วันที่ 2**:
     - หายป่วย: 0 (heal[2] = 0)
     - ป่วยใหม่: 5 (1 วัน) + 4 (3 วัน) = 9
     - current = 20 - 0 + 9 = 29
     - heal[3] += 5 (เป็น 15), heal[5] += 4
     - พิมพ์ 29

### โค้ดในภาษา C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N;
    cin >> N;  // อ่านจำนวนวันทั้งหมด

    vector<int> heal(N + 25, 0);  // สร้าง vector เพื่อเก็บจำนวนคนที่หายป่วยในแต่ละวัน
    int current = 0;  // จำนวนคนป่วยปัจจุบัน

    for (int i = 1; i <= N; i++) {
        // ลบคนที่หายป่วยในวันที่ i เวลา 8:00 น.
        current -= heal[i];

        // อ่านข้อมูลของวันที่ i
        int L;
        cin >> L;  // จำนวนกลุ่มผู้ป่วยใหม่

        for (int j = 0; j < L; j++) {
            int a, b;
            cin >> a >> b;  // อ่านจำนวนคน (a) และจำนวนวันที่ป่วย (b)
            current += a;  // เพิ่มคนป่วยใหม่เข้า current
            heal[i + b] += a;  // บันทึกจำนวนคนที่จะหายป่วยในวันที่ i + b
        }

        // พิมพ์จำนวนคนป่วยที่เวลา 12:00 น.
        cout << current << endl;
    }

    return 0;
}
```

### อธิบายโค้ดทีละส่วน

1. **`#include <bits/stdc++.h>`**:
   - รวม header ทั้งหมดที่จำเป็น เช่น `<iostream>` และ `<vector>`

2. **`int N; cin >> N;`**:
   - อ่านจำนวนวันทั้งหมด (N) จาก input

3. **`vector<int> heal(N + 25, 0);`**:
   - สร้าง vector ขนาด N + 25 โดยทุกตำแหน่งเริ่มต้นเป็น 0
   - ขนาด N + 25 เพื่อรองรับวันที่เกิน N (สูงสุด Bj = 20) แต่เราไม่สนใจเกิน N

4. **`int current = 0;`**:
   - ตัวแปรเก็บจำนวนคนป่วยที่ยังป่วยอยู่ เริ่มต้นเป็น 0

5. **`for (int i = 1; i <= N; i++)`**:
   - วนลูปตั้งแต่วันที่ 1 ถึง N

6. **`current -= heal[i];`**:
   - ลบจำนวนคนที่หายป่วยในวันที่ i ออก เพราะหายเวลา 8:00 น. ก่อนถึง 12:00 น.

7. **`int L; cin >> L;`**:
   - อ่านจำนวนกลุ่มผู้ป่วยใหม่ (L) ในวันที่ i

8. **`for (int j = 0; j < L; j++)`**:
   - วนลูป L ครั้งเพื่ออ่านข้อมูลแต่ละกลุ่ม

9. **`cin >> a >> b;`**:
   - อ่านจำนวนคน (a) และจำนวนวันที่ป่วย (b) ของกลุ่มที่ j

10. **`current += a;`**:
    - เพิ่มจำนวนคนป่วยใหม่เข้าไปใน `current`

11. **`heal[i + b] += a;`**:
    - บันทึกว่ามีคนจำนวน a จะหายป่วยในวันที่ i + b

12. **`cout << current << endl;`**:
    - พิมพ์จำนวนคนป่วยที่เวลา 12:00 น. ของวันที่ i

### การทดสอบกับตัวอย่าง

**Input**:
```
8
2 10 2 10 5
2 5 1 4 3
0
1 3 10
0
0
0
0
```

**การทำงาน**:

- **วันที่ 1**:
  - `current = 0 - heal[1] (0) = 0`
  - `L = 2`
  - กลุ่ม 1: `a = 10, b = 2`, `current += 10 = 10`, `heal[3] += 10`
  - กลุ่ม 2: `a = 10, b = 5`, `current += 10 = 20`, `heal[6] += 10`
  - พิมพ์ `20`

- **วันที่ 2**:
  - `current = 20 - heal[2] (0) = 20`
  - `L = 2`
  - กลุ่ม 1: `a = 5, b = 1`, `current += 5 = 25`, `heal[3] += 5 (เป็น 15)`
  - กลุ่ม 2: `a = 4, b = 3`, `current += 4 = 29`, `heal[5] += 4`
  - พิมพ์ `29`

- **วันที่ 3**:
  - `current = 29 - heal[3] (15) = 14`
  - `L = 0`, ไม่มีคนป่วยใหม่
  - พิมพ์ `14`

- **วันที่ 4**:
  - `current = 14 - heal[4] (0) = 14`
  - `L = 1`
  - กลุ่ม 1: `a = 3, b = 10`, `current += 3 = 17`, `heal[14] += 3`
  - พิมพ์ `17`

- **วันที่ 5**:
  - `current = 17 - heal[5] (4) = 13`
  - `L = 0`
  - พิมพ์ `13`

- **วันที่ 6**:
  - `current = 13 - heal[6] (10) = 3`
  - `L = 0`
  - พิมพ์ `3`

- **วันที่ 7**:
  - `current = 3 - heal[7] (0) = 3`
  - `L = 0`
  - พิมพ์ `3`

- **วันที่ 8**:
  - `current = 3 - heal[8] (0) = 3`
  - `L = 0`
  - พิมพ์ `3`

**Output**:
```
20
29
14
17
13
3
3
3
```

ผลลัพธ์ตรงกับที่โจทย์ระบุ โค้ดจึงทำงานถูกต้อง

### ข้อสังเกตเพิ่มเติม
- โค้ดนี้มีประสิทธิภาพ O(N * L) ซึ่งเพียงพอสำหรับ N ≤ 1000 และ L ≤ 10
- ใช้หน่วยความจำ O(N) สำหรับ vector `heal`
- ไม่จำเป็นต้องเช็ค `i + b <= N + 20` เพราะขนาดของ `heal` (N + 25) ใหญ่เพียงพอ และเราไม่สนใจวันที่เกิน N

หวังว่าคำอธิบายนี้จะช่วยให้เข้าใจโจทย์และโค้ดอย่างละเอียดครับ!