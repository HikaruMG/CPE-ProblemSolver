ด้านล่างนี้คือแนวทางแก้ปัญหาโดยใช้ภาษา C++ พร้อมคำอธิบายขั้นตอนและตัวอย่างการทำงาน

---

## แนวคิดและขั้นตอนแก้ปัญหา

เมืองมีแยก \(N\) และถนน \(M\) เส้น โดยถนนบางเส้นเป็นสะพานที่เชื่อมระหว่างฝั่ง 1 และฝั่ง 2  
โดยที่บ้านอยู่ที่แยก \(S\) (ฝั่ง 1) และโรงเรียนอยู่ที่แยก \(T\) (ฝั่ง 2)  
เงื่อนไขของการเดินทางคือ
- **เดินทางไปโรงเรียน (ตอนเช้า):**  
  ต้องเดินจาก \(S\) (ฝั่ง 1) ไปยังจุดบนฝั่ง 1 ที่อยู่ติดกับสะพาน (เรียกว่า \(u\)) จากนั้นข้ามสะพาน (นับเป็น 1 เส้น) ไปยังฝั่ง 2 ที่จุด \(v\) แล้วเดินจาก \(v\) ไปยัง \(T\) ด้วยถนนในฝั่ง 2  
  ค่าใช้จ่าย = ระยะทาง \(S \to u\) + 1 (สะพาน) + ระยะทาง \(v \to T\)

- **เดินทางกลับบ้าน (ตอนเย็น):**  
  เดินจาก \(T\) (ฝั่ง 2) ไปยังจุด \(v\) บนฝั่ง 2 จากนั้นข้ามสะพาน (1 เส้น) ไปยังฝั่ง 1 ที่จุด \(u\) แล้วเดินจาก \(u\) ไปยัง \(S\)  
  ค่าใช้จ่าย = ระยะทาง \(T \to v\) + 1 (สะพาน) + ระยะทาง \(u \to S\)

เนื่องจากกราฟเป็นแบบไม่ทิศทาง (ระยะทาง S→u เท่ากับ u→S และ T→v เท่ากับ v→T)  
ถ้าใช้สะพานใดสะพานหนึ่ง ค่าใช้จ่ายของเส้นทางจะเท่ากับ  
\[
\text{cost} = \text{dist1}[u] + 1 + \text{dist2}[v]
\]
โดยที่  
- \(\text{dist1}[u]\) คือระยะทางจาก \(S\) ไปยัง \(u\) ในกราฟของฝั่ง 1 (ถนนที่ไม่ใช่สะพาน)  
- \(\text{dist2}[v]\) คือระยะทางจาก \(T\) ไปยัง \(v\) ในกราฟของฝั่ง 2

อย่างไรก็ตามเราไม่สามารถใช้สะพานเดียวกันทั้งสองเส้นทางได้  
ดังนั้นเราต้องเลือก **สะพานสองเส้นที่แตกต่างกัน**  
โดยให้เลือกสะพานที่ให้ค่า \(\text{dist1}[u] + \text{dist2}[v]\) น้อยที่สุด 2 ตัว  
แล้วผลรวมของสองเส้นทางจะเป็น  
\[
(\text{candidate}_1 + 1) + (\text{candidate}_2 + 1) = \text{candidate}_1 + \text{candidate}_2 + 2
\]
โดยที่ \(\text{candidate} = \text{dist1}[u] + \text{dist2}[v]\) สำหรับแต่ละสะพาน

### ขั้นตอนหลักในการแก้ปัญหา
1. **อ่านข้อมูลและแบ่งกราฟ**  
   - อ่านข้อมูลฝั่งของแยก \(X[i]\)  
   - สำหรับแต่ละถนน ถ้าแยกทั้งสองอยู่ในฝั่งเดียวกัน (ไม่ใช่สะพาน) ให้นำไปใส่ในกราฟของฝั่งนั้น  
   - ถ้าเป็นถนนที่เชื่อมระหว่างฝั่ง ให้นับเป็นสะพานและเก็บไว้ใน candidate list โดยจัดให้อยู่ในรูป \((u,v)\) โดย \(u\) อยู่ฝั่ง 1 และ \(v\) อยู่ฝั่ง 2

2. **คำนวณระยะทางด้วย Dijkstra**  
   - รัน Dijkstra จาก \(S\) บนกราฟของฝั่ง 1 เพื่อหาค่า \(\text{dist1}[u]\)  
   - รัน Dijkstra จาก \(T\) บนกราฟของฝั่ง 2 เพื่อหาค่า \(\text{dist2}[v]\)

3. **เลือกสะพานที่เป็น candidate**  
   - สำหรับแต่ละสะพาน \((u,v)\) ที่ได้ หากทั้ง \(\text{dist1}[u]\) และ \(\text{dist2}[v]\) สามารถเข้าถึงได้ (ไม่เป็นอนันต์) ให้คำนวณ candidate cost = \(\text{dist1}[u] + \text{dist2}[v]\)

4. **คำนวณคำตอบ**  
   - ถ้าจำนวน candidate น้อยกว่า 2 ให้แสดง \(-1\)  
   - หากมี candidate อย่างน้อย 2 ให้เลือกสองค่า candidate ที่น้อยที่สุด แล้วผลรวมคำตอบ = (candidate1 + candidate2 + 2)

---

## ตัวอย่างการทำงาน

### ตัวอย่างที่ 1
**Input:**  
```
11 13 1 7
1 1 1 2 2 2 2 2 2 2 2
1 2
1 3
5 2
3 9
8 3
8 10
11 5
11 9
5 4
4 7
7 5
7 6
11 6
```

- **ฝั่งของแยก:** แยก 1,2,3 อยู่ฝั่ง 1; แยกที่เหลืออยู่ฝั่ง 2  
- **สะพานที่ได้:**  
  - สะพานระหว่าง 2 (ฝั่ง 1) กับ 5 (ฝั่ง 2)  
  - สะพานระหว่าง 3 (ฝั่ง 1) กับ 9 (ฝั่ง 2)  
  - สะพานระหว่าง 3 (ฝั่ง 1) กับ 8 (ฝั่ง 2) แต่ \(8\) ไม่เข้าถึงจาก \(T=7\)
  
- **คำนวณระยะทาง**  
  - บนฝั่ง 1 จาก \(S=1\):  
    \(\text{dist1}[2] = 1,\ \text{dist1}[3] = 1\)
  - บนฝั่ง 2 จาก \(T=7\):  
    \(\text{dist2}[5] = 1,\ \text{dist2}[9] = 3\)
  
- **Candidate cost:**  
  - สำหรับสะพาน \((2,5)\): \(1 + 1 = 2\)  
  - สำหรับสะพาน \((3,9)\): \(1 + 3 = 4\)
  
- **ผลคำตอบ:** \(2 + 4 + 2 = 8\)

### ตัวอย่างที่ 2
**Input:**  
```
11 13 1 10
1 1 1 2 2 2 2 2 2 2 2
1 2
1 3
5 2
3 9
8 3
8 10
11 5
11 9
5 4
4 7
7 5
7 6
11 6
```

- โรงเรียน \(T=10\) อยู่ในส่วนที่เชื่อมกันระหว่าง 8-10 ซึ่งแยกออกจากส่วนอื่น  
- **Candidate:**  
  - มีเพียงสะพาน \((3,8)\) ที่สามารถใช้ได้ (เนื่องจาก \( \text{dist1}[3]=1\) และ \(\text{dist2}[8]=1\))  
  - สะพานอื่นไม่สามารถเข้าถึงจาก \(T\) ได้  
- เนื่องจากมี candidate เพียงตัวเดียว ไม่สามารถเลือกสะพานที่แตกต่างกัน 2 เส้น  
- **ผลคำตอบ:** \(-1\)

---

## โค้ดภาษา C++ พร้อมคำอธิบาย inline

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
const long long INF = 1e18; // กำหนดค่าที่ใช้แทนอันนันต์

// โครงสร้างสำหรับเก็บข้อมูลของเส้นทางในกราฟ
struct Edge {
    int to, weight;
};

// ฟังก์ชัน Dijkstra เพื่อคำนวณระยะทางจากจุดเริ่มต้นในกราฟ
void dijkstra(int start, vector<long long> &dist, const vector<vector<Edge>> &graph) {
    int n = graph.size();
    // priority queue แบบ min-heap เพื่อเลือก node ที่มีระยะทางน้อยที่สุด
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
    dist[start] = 0;
    pq.push({0, start});
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        // หากค่า d ไม่ตรงกับระยะทางที่คำนวณไว้ให้ข้ามไป
        if (d != dist[u]) continue;
        // อัปเดตระยะทางของเพื่อนบ้าน
        for (auto &edge : graph[u]) {
            int v = edge.to;
            long long nd = d + edge.weight;
            if (nd < dist[v]) {
                dist[v] = nd;
                pq.push({nd, v});
            }
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M, S, T;
    cin >> N >> M >> S >> T;
    vector<int> side(N + 1);
    for (int i = 1; i <= N; i++){
        cin >> side[i];
    }
    
    // สร้างกราฟสำหรับฝั่ง 1 และฝั่ง 2 (เฉพาะถนนที่ไม่ใช่สะพาน)
    vector<vector<Edge>> graph1(N + 1), graph2(N + 1);
    // เก็บสะพานในรูปแบบ (u, v) โดย u อยู่ฝั่ง 1 และ v อยู่ฝั่ง 2
    vector<pair<int,int>> bridges;
    
    for (int i = 0; i < M; i++){
        int u, v;
        cin >> u >> v;
        // ถ้าแยกทั้งสองอยู่ในฝั่งเดียวกัน = ไม่ใช่สะพาน
        if (side[u] == side[v]) {
            if (side[u] == 1) {
                graph1[u].push_back({v, 1});
                graph1[v].push_back({u, 1});
            } else {
                graph2[u].push_back({v, 1});
                graph2[v].push_back({u, 1});
            }
        } else {
            // ถ้าเป็นสะพาน ให้จัดเก็บโดยให้ u อยู่ฝั่ง 1 และ v อยู่ฝั่ง 2
            if (side[u] == 1) {
                bridges.push_back({u, v});
            } else {
                bridges.push_back({v, u});
            }
        }
    }
    
    // คำนวณระยะทางในฝั่ง 1 จาก S
    vector<long long> dist1(N + 1, INF);
    dijkstra(S, dist1, graph1);
    
    // คำนวณระยะทางในฝั่ง 2 จาก T
    vector<long long> dist2(N + 1, INF);
    dijkstra(T, dist2, graph2);
    
    // เก็บ candidate cost สำหรับแต่ละสะพาน ที่สามารถเดินทางได้จริง
    vector<long long> candidates;
    for (auto &b : bridges) {
        int u = b.first;  // จุดบนฝั่ง 1
        int v = b.second; // จุดบนฝั่ง 2
        if (dist1[u] < INF && dist2[v] < INF) {
            candidates.push_back(dist1[u] + dist2[v]);
        }
    }
    
    // หากมี candidate น้อยกว่า 2 แสดงว่าไม่สามารถเลือกสะพานสองเส้นที่แตกต่างกันได้
    if (candidates.size() < 2) {
        cout << -1;
        return 0;
    }
    
    // เลือก candidate สองค่าที่น้อยที่สุด
    sort(candidates.begin(), candidates.end());
    // ผลรวมทั้งหมด = candidate[0] + candidate[1] + 2 (เพิ่ม 2 สำหรับการข้ามสะพาน 2 เส้น)
    long long ans = candidates[0] + candidates[1] + 2;
    cout << ans;
    
    return 0;
}
```

---

## สรุป

1. เราสร้างกราฟของถนนในฝั่ง 1 และฝั่ง 2แยกกัน (ไม่รวมสะพาน)  
2. ใช้ Dijkstra เพื่อคำนวณระยะทางจาก \(S\) (ฝั่ง 1) และจาก \(T\) (ฝั่ง 2)  
3. สำหรับสะพานแต่ละเส้น (โดยจัดให้อยู่ในรูป \((u,v)\) เมื่อ \(u\) อยู่ฝั่ง 1 และ \(v\) อยู่ฝั่ง 2) หาก \(u\) และ \(v\) เข้าถึงได้ ให้คำนวณ candidate cost = \(\text{dist1}[u] + \text{dist2}[v]\)  
4. หาก candidate มีอย่างน้อย 2 ตัว เลือกสองค่าที่น้อยที่สุด ผลลัพธ์คือ candidate1 + candidate2 + 2  
5. หาก candidate น้อยกว่า 2 ให้แสดง \(-1\)

ด้วยแนวทางนี้ เราจะได้โปรแกรมที่คำนวณเส้นทางเดินที่ใช้ถนนจำนวนน้อยที่สุดภายใต้เงื่อนไขที่ระบุไว้ในโจทย์

หวังว่าจะเป็นประโยชน์และช่วยให้เข้าใจวิธีการแก้ปัญหานี้ได้ชัดเจนมากขึ้น!