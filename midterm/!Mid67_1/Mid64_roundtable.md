### คำอธิบายโจทย์

โจทย์นี้เกี่ยวกับการจัดเรียงอาหารบนโต๊ะวงกลมที่มีจานหมุนได้ โดยมีคน **N** คนนั่งรอบโต๊ะ และมีอาหาร **N** อย่างวางอยู่หน้าพวกเขา แต่ตำแหน่งของอาหารอาจไม่ตรงกับคนที่สั่ง เป้าหมายคือหาวิธีหมุนจานอาหารเพียงครั้งเดียวเพื่อให้คนได้กินอาหารที่ตนเองสั่งมากที่สุด

#### รายละเอียด:
- **คน**: มี **N** คน (1 ≤ N ≤ 200,000) นั่งเรียงเป็นวงกลม ตั้งแต่หมายเลข 1 ถึง N
- **อาหาร**: มี **N** จาน วางตรงหน้าคนแต่ละคน โดยอาหารที่ตำแหน่ง **j** (เรียกว่า Fj) เป็นอาหารที่คนหมายเลข **Fj** สั่ง ซึ่ง Fj เป็นการเรียงสับเปลี่ยน (permutation) ของตัวเลข 1 ถึง N
- **การหมุน**: สามารถหมุนจานอาหารได้เป็นวงกลม ทำให้อาหารทุกจานเลื่อนไปพร้อมกันในทิศทางเดียวกัน
- **คำถาม**: หลังจากหมุนจานอาหารหนึ่งครั้ง จะมีคนได้กินอาหารที่ตนเองสั่งมากที่สุดกี่คน?

#### ข้อมูลนำเข้า:
- บรรทัดแรก: จำนวนเต็ม **N**
- บรรทัดที่สอง: ลำดับ **F1, F2, ..., FN** ซึ่งแต่ละตัวเลขอยู่ในช่วง 1 ถึง N และไม่ซ้ำกัน

#### ข้อมูลส่งออก:
- จำนวนเต็มหนึ่งจำนวน แทนจำนวนคนสูงสุดที่ได้กินอาหารที่ตนเองสั่งหลังจากการหมุน

---

### ขั้นตอนการคิด

เพื่อแก้ปัญหานี้ เราจะวิเคราะห์และออกแบบวิธีแก้ทีละขั้นตอน:

#### 1. ทำความเข้าใจการหมุนโต๊ะวงกลม
- โต๊ะเป็นวงกลม และการหมุนจานอาหารจะเลื่อนตำแหน่งของอาหารทั้งหมดพร้อมกัน
- หากหมุนไปทางขวา (ตามเข็มนาฬิกา) **k** ตำแหน่ง:
  - อาหารที่เดิมอยู่ตำแหน่ง **j** จะไปอยู่ที่ตำแหน่ง **(j + k) mod N**
  - แต่ในมุมมองของคนที่ตำแหน่ง **j** ซึ่งยังนั่งอยู่ที่เดิม อาหารที่อยู่หน้าพวกเขาจะมาจากตำแหน่ง **(j - k) mod N**
- ดังนั้น หลังจากหมุน **k** ตำแหน่ง อาหารที่อยู่หน้าคนที่ตำแหน่ง **j** จะเป็น **F[(j - k) mod N]**

#### 2. เงื่อนไขที่คนได้กินอาหารที่ตนเองสั่ง
- คนที่ตำแหน่ง **j** จะได้กินอาหารที่ตนเองสั่ง ถ้าอาหารที่อยู่หน้าพวกเขา (คือ **F[(j - k) mod N]**) เป็นของคนที่ **j**
- จากโจทย์ **F[x]** หมายถึงอาหารที่ตำแหน่ง **x** เป็นของคนที่ **F[x]**
- ดังนั้น เราต้องการ **F[(j - k) mod N] = j**

#### 3. การหาค่า k ที่เหมาะสม
- สำหรับแต่ละตำแหน่ง **j** เราสามารถหาค่า **k** ที่ทำให้เงื่อนไขนี้เป็นจริงได้
- กำหนด **F_inv** เป็น inverse permutation ของ **F**:
  - **F_inv[i] = j** ถ้า **F[j] = i**
  - นั่นคือ **F_inv[i]** บอกว่าอาหารของคนที่ **i** อยู่ที่ตำแหน่ง **j**
- ถ้าเราต้องการ **F[(j - k) mod N] = j**:
  - ให้ **(j - k) mod N = F_inv[j]**
  - ดังนั้น **j - k ≡ F_inv[j] (mod N)**
  - หรือ **k ≡ j - F_inv[j] (mod N)**
- เพื่อให้ **k** เป็นบวกเสมอในภาษา C++ (ที่การ mod กับจำนวนลบอาจให้ผลลัพธ์ไม่คาดหวัง) ใช้:
  - **k = (j - F_inv[j] + N) % N**

#### 4. การนับจำนวนคนที่ได้กินอาหารที่สั่ง
- สำหรับแต่ละ **j** (0 ถึง N-1) คำนวณ **k** ที่ทำให้คนที่ **j** ได้กินอาหารที่สั่ง
- ใช้ array **count[k]** เพื่อนับว่าการหมุน **k** ตำแหน่ง ทำให้มีคนได้กินอาหารที่สั่งกี่คน
- หาค่า **k** ที่ทำให้ **count[k]** สูงสุด ซึ่งจะเป็นคำตอบ

#### 5. ความซับซ้อน
- การสร้าง **F_inv**: O(N)
- การคำนวณ **k** สำหรับแต่ละ **j**: O(N)
- การหาค่าสูงสุดใน **count**: O(N)
- รวม: **O(N)** ซึ่งเหมาะสมกับข้อจำกัด N ≤ 200,000

---

### โปรแกรมในภาษา C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N;
    cin >> N;
    
    // อ่าน array F และปรับเป็น 0-based
    vector<int> F(N);
    for(int i = 0; i < N; i++) {
        cin >> F[i];
        F[i]--;  // เปลี่ยนจาก 1-based เป็น 0-based
    }
    
    // สร้าง inverse permutation F_inv
    vector<int> F_inv(N);
    for(int j = 0; j < N; j++) {
        F_inv[F[j]] = j;
    }
    
    // นับจำนวนคนที่ได้กินอาหารที่สั่งสำหรับแต่ละ k
    vector<int> count(N, 0);
    for(int j = 0; j < N; j++) {
        int k = (j - F_inv[j] + N) % N;
        count[k]++;
    }
    
    // หาค่าสูงสุด
    int max_count = 0;
    for(int k = 0; k < N; k++) {
        if(count[k] > max_count) {
            max_count = count[k];
        }
    }
    
    cout << max_count << endl;
    return 0;
}
```

---

### อธิบายโค้ดทีละส่วน

#### 1. **Include และ Namespace**
```cpp
#include <bits/stdc++.h>
using namespace std;
```
- รวม header ที่จำเป็นทั้งหมด (เช่น vector, iostream)
- ใช้ namespace std เพื่อลดการพิมพ์ std::

#### 2. **อ่านข้อมูลนำเข้า**
```cpp
int N;
cin >> N;
vector<int> F(N);
for(int i = 0; i < N; i++) {
    cin >> F[i];
    F[i]--;  // เปลี่ยนจาก 1-based เป็น 0-based
}
```
- อ่าน **N** จากบรรทัดแรก
- สร้าง vector **F** ขนาด **N** และอ่านค่า **F1, F2, ..., FN**
- ปรับค่าให้เป็น 0-based (เช่น 1 กลายเป็น 0, 2 กลายเป็น 1) เพราะ C++ ใช้ index เริ่มที่ 0

#### 3. **สร้าง Inverse Permutation**
```cpp
vector<int> F_inv(N);
for(int j = 0; j < N; j++) {
    F_inv[F[j]] = j;
}
```
- สร้าง vector **F_inv** ขนาด **N**
- สำหรับแต่ละ **j** ถ้า **F[j] = i** แปลว่า **F_inv[i] = j**
- ตัวอย่าง: ถ้า **F[0] = 3** แปลว่า **F_inv[3] = 0**

#### 4. **คำนวณการหมุนและนับ**
```cpp
vector<int> count(N, 0);
for(int j = 0; j < N; j++) {
    int k = (j - F_inv[j] + N) % N;
    count[k]++;
}
```
- สร้าง vector **count** ขนาด **N** เพื่อนับจำนวนคนที่ได้กินอาหารที่สั่งสำหรับการหมุน **k** ตำแหน่ง
- สำหรับแต่ละ **j**:
  - คำนวณ **k = (j - F_inv[j] + N) % N** เพื่อหาการหมุนที่ทำให้คนที่ **j** ได้อาหารที่สั่ง
  - เพิ่ม **count[k]** ขึ้น 1
- การบวก **N** ก่อน mod รับประกันว่า **k** เป็นบวก

#### 5. **หาค่าสูงสุด**
```cpp
int max_count = 0;
for(int k = 0; k < N; k++) {
    if(count[k] > max_count) {
        max_count = count[k];
    }
}
```
- หาค่า **count[k]** ที่มากที่สุด ซึ่งคือจำนวนคนสูงสุดที่ได้กินอาหารที่สั่ง

#### 6. **แสดงผล**
```cpp
cout << max_count << endl;
```
- พิมพ์คำตอบ

---

### ตัวอย่างการทำงาน

#### ตัวอย่าง 1:
**Input:**
```
5
4 5 2 3 1
```
- **N = 5**
- **F = [3, 4, 1, 2, 0]** (ปรับจาก [4, 5, 2, 3, 1] เป็น 0-based)
- **F_inv**: 
  - F[0]=3 → F_inv[3]=0
  - F[1]=4 → F_inv[4]=1
  - F[2]=1 → F_inv[1]=2
  - F[3]=2 → F_inv[2]=3
  - F[4]=0 → F_inv[0]=4
  - ดังนั้น **F_inv = [4, 2, 3, 0, 1]**
- คำนวณ **k**:
  - j=0: k = (0 - 4 + 5) % 5 = 1 → count[1]++
  - j=1: k = (1 - 2 + 5) % 5 = 4 → count[4]++
  - j=2: k = (2 - 3 + 5) % 5 = 4 → count[4]++
  - j=3: k = (3 - 0 + 5) % 5 = 3 → count[3]++
  - j=4: k = (4 - 1 + 5) % 5 = 3 → count[3]++
- **count = [0, 1, 0, 2, 2]**
- **max_count = 2**
- **Output: 2**

#### ตัวอย่าง 2:
**Input:**
```
10
3 4 5 6 7 8 9 10 1 2
```
- **N = 10**
- **F = [2, 3, 4, 5, 6, 7, 8, 9, 0, 1]**
- **F_inv = [8, 9, 0, 1, 2, 3, 4, 5, 6, 7]**
- คำนวณ **k**:
  - j=0: k = (0 - 8 + 10) % 10 = 2
  - j=1: k = (1 - 9 + 10) % 10 = 2
  - ... (ทุก j ให้ k = 2 เพราะ F[j] = (j + 2) mod 10)
- **count[2] = 10**
- **max_count = 10**
- **Output: 10**

---

### สรุป
โปรแกรมนี้แก้ปัญหาโดยใช้แนวคิด permutation และการหมุนวงกลม ด้วยการคำนวณ inverse และนับการหมุนที่เหมาะสม ทำให้ได้คำตอบในเวลา **O(N)** ซึ่งเหมาะกับขนาดข้อมูลที่กำหนด คำตอบที่ได้สอดคล้องกับตัวอย่างทั้งสอง และสามารถจัดการกรณีทั่วไปได้อย่างถูกต้อง