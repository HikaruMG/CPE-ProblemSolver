ด้านล่างนี้คือแนวทางแก้โจทย์ด้วยภาษา C++ พร้อมทั้งอธิบายแนวคิดและโค้ดทีละส่วน รวมถึงตัวอย่างการทำงานของโปรแกรม

---

## แนวคิดและขั้นตอนการแก้ปัญหา

1. **การเก็บข้อมูลอินพุต:**  
   รับค่า R (จำนวนแถว) และ C (จำนวนคอลัมน์) แล้วรับตำแหน่งเริ่มต้น (A, B) และตำแหน่งปลายทาง (X, Y) (หมายเหตุ: แปลงเป็น index ตั้งแต่ 0 ในการเขียนโปรแกรม) จากนั้นรับข้อมูลแผนที่ซึ่งมีแต่ละเซลล์เป็น `#` (กำแพงหิน) `*` (กำแพงดิน) หรือ `.` (ทางเดิน)

2. **สถานะของการเดิน (State):**  
   เราต้องพิจารณาการเดินในสองสถานะ คือ  
   - **ยังไม่ใช้การเจาะ (used = 0)**  
   - **ใช้การเจาะไปแล้ว (used = 1)**  
   เราจะเก็บระยะทางที่น้อยที่สุดที่ไปถึงแต่ละเซลล์ในแต่ละสถานะด้วยตัวแปร `dist[r][c][used]`

3. **การเดินตามปกติ:**  
   จากเซลล์ที่เป็นทางเดิน ('.') เราสามารถเคลื่อนที่ไปยังเซลล์ที่ติดกัน (4 ทิศ: ขึ้น, ลง, ซ้าย, ขวา) ได้ หากเซลล์นั้นเป็นทางเดิน ('.') โดยแต่ละก้าวมีค่าใช้จ่ายเป็น 1

4. **การเจาะกำแพงดิน (Dig):**  
   หากยังไม่ใช้การเจาะ (used == 0) เราสามารถเลือกเจาะเซลล์ที่เป็นกำแพงดิน (`*`) ในทิศที่ต้องการได้โดยมีเงื่อนไขดังนี้  
   - **แนวตั้ง:**  
     - หากอยู่ที่เซลล์ (r, c) เป็นทางเดินและเซลล์ด้านล่าง (r+1, c) เป็นกำแพงดิน (`*`) และเซลล์ (r+2, c) เป็นทางเดิน (`.`)  
       → เราสามารถ “กระโดด” จาก (r, c) ไป (r+2, c) ด้วยการเจาะในแนวตั้งโดยมีค่าใช้จ่าย 2  
     - และในทิศขึ้น: หาก (r-1, c) เป็น `*` และ (r-2, c) เป็น `.` ก็สามารถกระโดดจาก (r, c) ไป (r-2, c)
   - **แนวนอน:**  
     - หาก (r, c+1) เป็น `*` และ (r, c+2) เป็น `.` ก็สามารถกระโดดจาก (r, c) ไป (r, c+2) ด้วยค่าใช้จ่าย 2  
     - และในทิศซ้าย: หาก (r, c-1) เป็น `*` และ (r, c-2) เป็น `.`
     
   หมายเหตุ: เมื่อใช้การเจาะแล้วสถานะเปลี่ยนเป็น used = 1 และไม่สามารถเจาะอีกได้

5. **การค้นหาเส้นทางที่สั้นที่สุด:**  
   เนื่องจากการเคลื่อนที่มีค่าใช้จ่าย 1 (เดินปกติ) และ 2 (การใช้ portal จากการเจาะ) เราสามารถใช้ **Dijkstra Algorithm** ในการหาเส้นทางที่มีค่าใช้จ่ายน้อยที่สุดใน state space (เซลล์, สถานะการเจาะ)

6. **กรณีที่ไม่มีทางเดินไปถึง:**  
   หากค้นหาแล้วไม่พบเส้นทางไปยังจุดปลายทางให้แสดงผลเป็น -1

---

## โค้ดภาษา C++

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <tuple>
#include <limits>
using namespace std;

const int INF = 1e9;

int main() {
    int R, C;
    cin >> R >> C;
    int A, B, X, Y;
    cin >> A >> B >> X >> Y;
    // แปลงตำแหน่งจาก 1-indexed เป็น 0-indexed
    A--; B--; X--; Y--;
    
    vector<string> grid(R);
    for (int i = 0; i < R; i++) {
        cin >> grid[i];
    }
    
    // dist[r][c][used]: ระยะทางน้อยที่สุดที่ไปถึงตำแหน่ง (r, c) โดย used = 0 (ยังไม่เจาะ) หรือ 1 (เจาะแล้ว)
    vector<vector<vector<int>>> dist(R, vector<vector<int>>(C, vector<int>(2, INF)));
    
    // ใช้ priority queue สำหรับ Dijkstra โดยเก็บ state เป็น (cost, r, c, used)
    typedef tuple<int, int, int, int> state;
    priority_queue<state, vector<state>, greater<state>> pq;
    
    // เริ่มที่ตำแหน่งเริ่มต้นโดยยังไม่ใช้การเจาะ
    dist[A][B][0] = 0;
    pq.push({0, A, B, 0});
    
    // กำหนดการเคลื่อนที่แบบปกติใน 4 ทิศ (ขึ้น, ซ้าย, ลง, ขวา)
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, -1, 0, 1};
    
    while (!pq.empty()) {
        auto [d, r, c, used] = pq.top();
        pq.pop();
        
        if (d != dist[r][c][used]) continue; // หาก state นี้ไม่ใช่ระยะทางที่ดีที่สุด ให้ข้ามไป
        
        // หากถึงจุดปลายทางแล้ว ให้แสดงผลและจบโปรแกรม
        if (r == X && c == Y) {
            cout << d << endl;
            return 0;
        }
        
        // 1. เคลื่อนที่ตามปกติ (เดินจากเซลล์หนึ่งไปยังเซลล์ที่ติดกัน ถ้าเป็นทางเดิน)
        for (int i = 0; i < 4; i++) {
            int nr = r + dr[i], nc = c + dc[i];
            if (nr < 0 || nr >= R || nc < 0 || nc >= C) continue;
            if (grid[nr][nc] != '.') continue; // เคลื่อนที่ได้เฉพาะเซลล์ที่เป็นทางเดิน ('.')
            if (dist[nr][nc][used] > d + 1) {
                dist[nr][nc][used] = d + 1;
                pq.push({d + 1, nr, nc, used});
            }
        }
        
        // 2. หากยังไม่ใช้การเจาะ (used == 0) ให้ลองใช้ portal
        if (used == 0) {
            // แนวตั้ง: ลง
            if (r + 1 < R && r + 2 < R) {
                if (grid[r+1][c] == '*' && grid[r+2][c] == '.') {
                    if (dist[r+2][c][1] > d + 2) {
                        dist[r+2][c][1] = d + 2;
                        pq.push({d + 2, r+2, c, 1});
                    }
                }
            }
            // แนวตั้ง: ขึ้น
            if (r - 1 >= 0 && r - 2 >= 0) {
                if (grid[r-1][c] == '*' && grid[r-2][c] == '.') {
                    if (dist[r-2][c][1] > d + 2) {
                        dist[r-2][c][1] = d + 2;
                        pq.push({d + 2, r-2, c, 1});
                    }
                }
            }
            
            // แนวนอน: ขวา
            if (c + 1 < C && c + 2 < C) {
                if (grid[r][c+1] == '*' && grid[r][c+2] == '.') {
                    if (dist[r][c+2][1] > d + 2) {
                        dist[r][c+2][1] = d + 2;
                        pq.push({d + 2, r, c+2, 1});
                    }
                }
            }
            // แนวนอน: ซ้าย
            if (c - 1 >= 0 && c - 2 >= 0) {
                if (grid[r][c-1] == '*' && grid[r][c-2] == '.') {
                    if (dist[r][c-2][1] > d + 2) {
                        dist[r][c-2][1] = d + 2;
                        pq.push({d + 2, r, c-2, 1});
                    }
                }
            }
        }
    }
    
    // หากค้นหาเสร็จแล้วยังไม่พบเส้นทาง ให้แสดงผล -1
    cout << -1 << endl;
    return 0;
}
```

---

## การอธิบายโค้ดทีละส่วน

1. **ส่วนของการอ่านข้อมูลอินพุต**  
   ```cpp
   int R, C;
   cin >> R >> C;
   int A, B, X, Y;
   cin >> A >> B >> X >> Y;
   A--; B--; X--; Y--;
   vector<string> grid(R);
   for (int i = 0; i < R; i++) {
       cin >> grid[i];
   }
   ```  
   โค้ดส่วนนี้รับค่า R, C, ตำแหน่งเริ่มต้นและปลายทาง แล้วอ่านข้อมูลแผนที่จากอินพุต

2. **การเตรียมตัวแปรสำหรับเก็บระยะทาง (Distance Array)**  
   ```cpp
   vector<vector<vector<int>>> dist(R, vector<vector<int>>(C, vector<int>(2, INF)));
   ```  
   เราสร้างอาเรย์ 3 มิติสำหรับเก็บระยะทางที่น้อยที่สุดของแต่ละเซลล์ในแต่ละสถานะ (ยังไม่ใช้เจาะหรือใช้แล้ว)

3. **การใช้ Priority Queue สำหรับ Dijkstra**  
   ```cpp
   typedef tuple<int, int, int, int> state;
   priority_queue<state, vector<state>, greater<state>> pq;
   
   dist[A][B][0] = 0;
   pq.push({0, A, B, 0});
   ```  
   กำหนด state ที่เก็บข้อมูลเป็น (ระยะทาง, แถว, คอลัมน์, used) แล้วเริ่มจากตำแหน่งเริ่มต้น

4. **การเคลื่อนที่ตามปกติ**  
   ```cpp
   int dr[4] = {-1, 0, 1, 0};
   int dc[4] = {0, -1, 0, 1};
   for (int i = 0; i < 4; i++) {
       int nr = r + dr[i], nc = c + dc[i];
       if (nr < 0 || nr >= R || nc < 0 || nc >= C) continue;
       if (grid[nr][nc] != '.') continue;
       if (dist[nr][nc][used] > d + 1) {
           dist[nr][nc][used] = d + 1;
           pq.push({d + 1, nr, nc, used});
       }
   }
   ```  
   จากตำแหน่งปัจจุบัน (r, c) เคลื่อนที่ไปยังเซลล์ที่ติดกันที่เป็นทางเดิน ('.') โดยเพิ่มระยะทาง 1

5. **การใช้การเจาะกำแพงดิน (Dig Portal)**  
   ```cpp
   if (used == 0) {
       // แนวตั้ง: ลง
       if (r + 1 < R && r + 2 < R) {
           if (grid[r+1][c] == '*' && grid[r+2][c] == '.') {
               if (dist[r+2][c][1] > d + 2) {
                   dist[r+2][c][1] = d + 2;
                   pq.push({d + 2, r+2, c, 1});
               }
           }
       }
       // แนวตั้ง: ขึ้น
       if (r - 1 >= 0 && r - 2 >= 0) {
           if (grid[r-1][c] == '*' && grid[r-2][c] == '.') {
               if (dist[r-2][c][1] > d + 2) {
                   dist[r-2][c][1] = d + 2;
                   pq.push({d + 2, r-2, c, 1});
               }
           }
       }
       
       // แนวนอน: ขวา
       if (c + 1 < C && c + 2 < C) {
           if (grid[r][c+1] == '*' && grid[r][c+2] == '.') {
               if (dist[r][c+2][1] > d + 2) {
                   dist[r][c+2][1] = d + 2;
                   pq.push({d + 2, r, c+2, 1});
               }
           }
       }
       // แนวนอน: ซ้าย
       if (c - 1 >= 0 && c - 2 >= 0) {
           if (grid[r][c-1] == '*' && grid[r][c-2] == '.') {
               if (dist[r][c-2][1] > d + 2) {
                   dist[r][c-2][1] = d + 2;
                   pq.push({d + 2, r, c-2, 1});
               }
           }
       }
   }
   ```  
   หากยังไม่ใช้การเจาะ (used == 0) เราจะตรวจสอบในทิศทั้งสี่ว่ามีเซลล์กำแพงดินอยู่ตรงข้ามและเซลล์อีกด้านหนึ่งเป็นทางเดินหรือไม่ หากเป็นจริง เราจะ “กระโดด” ไปยังเซลล์นั้นด้วยค่าใช้จ่าย 2 แล้วเปลี่ยนสถานะเป็น used = 1

6. **การตรวจสอบว่ามีเส้นทางไปถึงจุดหมาย:**  
   เมื่อ state ที่ดึงจาก priority queue มีตำแหน่งตรงกับจุดปลายทาง (X, Y) เราจะแสดงค่า d (ระยะทางที่น้อยที่สุด) แล้วจบโปรแกรม  
   หากไม่มี state ใด ๆ ที่ไปถึงปลายทาง โปรแกรมจะแสดงผล -1

---

## ตัวอย่างการทำงาน

**ตัวอย่างอินพุตที่ 1:**  
```
6 5
2 2 4 2
#####
#...#
#**.#
#.*.#
#...#
#####
```  
- จุดเริ่มต้นที่ (2,2) และปลายทางที่ (4,2)  
- หากเดินตามปกติจะต้องเดิน 8 ตา  
- แต่ถ้าเลือกเจาะเซลล์ที่ (3,2) แบบแนวตั้ง (เพราะ (2,2) กับ (4,2) จะได้เชื่อมกัน) จะใช้ค่าใช้จ่ายเพียง 2  
**ผลลัพธ์ที่ได้:** 2

**ตัวอย่างอินพุตที่ 2:**  
```
6 5
2 2 5 2
#####
#...#
#***#
#***#
#...#
#####
```  
ในกรณีนี้ไม่มีวิธีเดินที่สามารถไปถึงปลายทางได้แม้จะใช้การเจาะได้หนึ่งครั้ง  
**ผลลัพธ์ที่ได้:** -1

---

โค้ดตัวอย่างข้างต้นเป็นแนวทางในการแก้ปัญหาโดยใช้การค้นหาแบบ Dijkstra ใน state space ที่มีสองสถานะ (เจาะแล้ว/ยังไม่เจาะ) ซึ่งครอบคลุมทั้งการเดินตามปกติและการใช้การเจาะกำแพงดินให้เกิดเป็น “portal” เพื่อเชื่อมระหว่างเซลล์ที่ห่างกันสองตำแหน่งในแนวตั้งหรือแนวนอน

หวังว่าแนวทางและการอธิบายนี้จะช่วยให้เข้าใจวิธีแก้ปัญหานี้ได้ชัดเจนยิ่งขึ้นครับ!