## วิเคราะห์โจทย์
โจทย์นี้กำหนดให้มีถนนเส้นหลักที่มีร้านซูชิตั้งอยู่ตามจุดต่าง ๆ และอาจมีร้านอยู่ในซอยที่แยกจากถนนหลัก ร้านแต่ละร้านต้องได้รับปลาให้ทันภายในระยะทางที่กำหนด \( L \) หน่วย ซึ่งวัดตามเส้นทางเดินจริง (ไม่ใช่ระยะทางเชิงเรขาคณิต)

### **การพิจารณาระยะทาง**
1. แต่ละร้านมีตำแหน่งที่กำหนดโดย \( A[i] \) (ระยะทางจากจุดเริ่มของถนน) และ \( B[i] \) (ความลึกของซอย ถ้าอยู่บนถนนหลัก \( B[i] = 0 \))
2. ร้านที่อยู่ที่ตำแหน่ง \( (A, B) \) ต้องได้รับปลาโดยมีระยะทางรวมจากบ่อเลี้ยงปลาไปยังร้าน ≤ \( L \)
3. ระยะทางระหว่างบ่อปลาและร้านคำนวณเป็น:
   \[
   \text{ระยะทาง} = |A_{\text{pond}} - A_{\text{shop}}| + B_{\text{shop}}
   \]

### **เป้าหมาย**
- ต้องการหาตำแหน่งของบ่อปลาให้น้อยที่สุด ที่สามารถครอบคลุมทุกสาขาภายในระยะ \( L \)
- ถ้าไม่สามารถทำได้ให้คืนค่า `-1`

---

## **แนวคิดในการแก้ปัญหา**
1. **สร้างช่วงที่ร้านสามารถเข้าถึงได้**  
   - คำนวณช่วงที่แต่ละร้านสามารถเข้าถึงบ่อปลา โดยใช้เงื่อนไข
     \[
     A[i] - (L - B[i]) \leq P \leq A[i] + (L - B[i])
     \]
     โดยที่ \( P \) คือ ตำแหน่งของบ่อปลา
   - แต่ละร้านจะถูกแทนด้วยช่วงที่สามารถมีบ่อปลาได้

2. **ใช้ Greedy Algorithm เพื่อวางบ่อปลา**  
   - เรียงช่วงตามจุดเริ่มต้น
   - ใช้ **sweep line** หรือ **interval covering**:
     - วางบ่อปลาที่ไกลที่สุดเท่าที่เป็นไปได้ภายในช่วงที่ครอบคลุมร้านทั้งหมดในช่วงปัจจุบัน
     - เลือกตำแหน่งที่สามารถครอบคลุมร้านจำนวนมากที่สุด

3. **ตรวจสอบเงื่อนไขว่าทุกช่วงถูกครอบคลุมหรือไม่**  
   - ถ้ามีช่วงที่ไม่สามารถวางบ่อปลาได้ภายในขีดจำกัด \( L \) ให้คืนค่า `-1`

---

## **การทำงานของโค้ด**
- **อ่านข้อมูลนำเข้า**
- **คำนวณช่วงที่ร้านต้องการบ่อปลา**
- **ใช้ Greedy Algorithm เพื่อเลือกตำแหน่งบ่อปลาให้น้อยที่สุด**
- **ตรวจสอบว่าเราครอบคลุมทุกช่วงได้หรือไม่**
- **คืนค่าจำนวนบ่อปลาที่ใช้**

---

## **โค้ดภาษา C++**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// โครงสร้างสำหรับช่วงของบ่อปลาที่สามารถตั้งได้
struct Interval {
    long long start, end;
};

// ฟังก์ชันหลัก
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    long long N, L;
    cin >> N >> L;

    vector<Interval> intervals;

    // อ่านข้อมูลร้านและคำนวณช่วงที่สามารถวางบ่อปลาได้
    for (int i = 0; i < N; ++i) {
        long long A, B;
        cin >> A >> B;
        if (B > L) {  // ถ้าร้านอยู่ลึกเกินไปจนรับปลาภายใน L ไม่ได้
            cout << -1 << endl;
            return 0;
        }
        long long reach = L - B;
        intervals.push_back({A - reach, A + reach});
    }

    // เรียงช่วงตามจุดเริ่มต้น
    sort(intervals.begin(), intervals.end(), [](const Interval &a, const Interval &b) {
        return a.start < b.start;
    });

    long long count = 0, covered = -1, i = 0;

    while (i < N) {
        if (intervals[i].start > covered) {
            // ถ้าพื้นที่ที่ครอบคลุมไม่สามารถครอบคลุมร้านนี้ ต้องเพิ่มบ่อใหม่
            long long best = intervals[i].end;
            while (i < N && intervals[i].start <= covered) {
                best = max(best, intervals[i].end);
                i++;
            }
            covered = best;
            count++;
        } else {
            i++;
        }
    }

    cout << count << endl;
    return 0;
}
```

---

## **การทำงานของโค้ด**
1. **อ่านค่า \( N \) และ \( L \)**
2. **คำนวณช่วงของแต่ละร้านที่สามารถตั้งบ่อปลาได้**
   - หากร้านใดมี \( B[i] > L \) แสดงว่าไม่สามารถได้รับปลาเลย → **ตอบ `-1` ทันที**
   - คำนวณ **ช่วงที่บ่อปลา** สามารถอยู่ได้สำหรับร้านแต่ละร้าน
   - เก็บช่วงเป็น **vector ของ intervals**
3. **เรียงช่วงตามจุดเริ่มต้น**
4. **ใช้ Greedy Algorithm:**
   - วางบ่อปลาให้ครอบคลุมร้านมากที่สุด
   - ถ้าช่วงที่ครอบคลุมอยู่ขาดช่วง ต้องวางบ่อเพิ่ม
5. **คืนค่าจำนวนบ่อปลาที่ใช้**

---

## **ตัวอย่างการทำงาน**
### **อินพุต**
```
3 10
1 0
5 3
15 0
```
### **การแปลงเป็นช่วง**
- ร้านที่ 1: `(1,0)` → บ่ออยู่ระหว่าง `[1-10, 1+10]` = `[-9, 11]`
- ร้านที่ 2: `(5,3)` → บ่ออยู่ระหว่าง `[5-7, 5+7]` = `[-2, 12]`
- ร้านที่ 3: `(15,0)` → บ่ออยู่ระหว่าง `[15-10, 15+10]` = `[5, 25]`

### **ช่วงหลังจากเรียง**
```
[-9, 11]
[-2, 12]
[5, 25]
```

### **เลือกบ่อปลา**
1. เริ่มจาก `[-9, 11]`, ตั้งบ่อที่ `11`
2. ร้านที่ 2 อยู่ในช่วง `[-2, 12]` → ครอบคลุมแล้ว
3. ร้านที่ 3 อยู่ในช่วง `[5, 25]` **แต่นอกช่วงเดิม** → ตั้งบ่อที่ `25`

### **เอาต์พุต**
```
2
```

---

## **สรุป**
- ใช้ **Greedy Algorithm + Interval Covering** เพื่อเลือกจุดวางบ่อปลาน้อยที่สุด
- ซับซ้อนที่สุดที่ \( O(N \log N) \) เนื่องจากเรียงข้อมูลและไล่ดูช่วง
- ถ้าพบว่าร้านใดอยู่ลึกเกิน \( L \) ตอบ `-1` ทันที
- ใช้ **sweep line** ในการวางบ่อปลาอย่างมีประสิทธิภาพ