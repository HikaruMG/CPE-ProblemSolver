### คำตอบสำหรับโจทย์

โจทย์นี้ต้องการให้เราออกแบบโปรแกรมภาษา C++ เพื่อแก้ปัญหาการตรวจสอบว่าสามารถสร้างไม้ค้ำถ่อที่มีความยาวตามที่ต้องการได้หรือไม่ โดยไม้ค้ำถ่อพิเศษประกอบด้วยไม้ขนาดเล็กจำนวน N ท่อน ซึ่งแต่ละท่อนมีหมายเลข 1 ถึง N และสามารถต่อกันได้เฉพาะท่อนที่อยู่ติดกันเท่านั้น (เช่น ท่อนที่ i ต่อได้กับท่อนที่ i-1 และ i+1) ดังนั้น ไม้ที่สร้างได้จะต้องเป็นผลรวมของความยาวจากท่อนที่เป็นช่วงต่อเนื่องกันเท่านั้น เราจะต้องตอบคำถาม Q ข้อ โดยแต่ละคำถามถามว่า ความยาว Q_i สามารถสร้างได้หรือไม่ โดยตอบเป็น "Y" (ได้) หรือ "N" (ไม่ได้)

ในคำตอบนี้ ผมจะอธิบายโจทย์ ขั้นตอนการคิด การออกแบบโปรแกรม โค้ดภาษา C++ พร้อมคำอธิบาย และยกตัวอย่างการทำงานอย่างละเอียด

---

### **การวิเคราะห์โจทย์**

จากโจทย์:
- ไม้ค้ำถ่อพิเศษประกอบด้วย **N ท่อน** (1 ≤ N ≤ 1,000) แต่ละท่อนมีความยาว **L_i** (1 ≤ L_i ≤ 1,000,000)
- ไม้ท่อนที่ i สามารถต่อได้เฉพาะกับท่อนที่ i-1 และ i+1 เท่านั้น หมายความว่า ความยาวที่สร้างได้จะเป็นผลรวมของไม้ในช่วงต่อเนื่องกัน เช่น L[i] + L[i+1] + ... + L[j] โดย j ≥ i
- มี **Q คำถาม** (1 ≤ Q ≤ 100,000) แต่ละคำถามให้ความยาว **Q_i** (1 ≤ Q_i ≤ 1,000,000,000) แล้วเราต้องตอบว่า Q_i สามารถสร้างได้หรือไม่

**ตัวอย่างจากโจทย์:**
- N = 5, ความยาวไม้ = [1, 3, 1, 4, 2] (ในโจทย์บอก 4 ท่อนคือ 1, 3, 1, 4 แต่บอก N=5 คาดว่าเป็นการพิมพ์ผิด ผมจะใช้ 1, 3, 1, 4, 2)
- ความยาวที่สร้างได้ เช่น:
  - ท่อน 1: 1
  - ท่อน 2: 3
  - ท่อน 3: 1
  - ท่อน 4: 4
  - ท่อน 5: 2
  - ท่อน 1-2: 1+3 = 4
  - ท่อน 2-3: 3+1 = 4
  - ท่อน 3-4: 1+4 = 5
  - ท่อน 4-5: 4+2 = 6
  - ท่อน 1-3: 1+3+1 = 5
  - ท่อน 2-4: 3+1+4 = 8
  - ท่อน 3-5: 1+4+2 = 7
  - ท่อน 1-4: 1+3+1+4 = 9
  - ท่อน 2-5: 3+1+4+2 = 10
  - ท่อน 1-5: 1+3+1+4+2 = 11
- ผลรวมที่เป็นไปได้ทั้งหมด: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
- โจทย์ตัวอย่างบอกว่าได้ 1, 3, 4, 5, 8, 9 ซึ่งอาจไม่ครบถ้วน แต่จากกติกา ควรได้ทุกผลรวมของช่วงต่อเนื่องกัน

**เป้าหมาย:** สำหรับแต่ละ Q_i ตรวจสอบว่า Q_i เป็นผลรวมของช่วงต่อเนื่องกันของ L หรือไม่

---

### **ขั้นตอนการคิด**

1. **การหาผลรวมของช่วงต่อเนื่องกัน:**
   - ผลรวมของไม้จากท่อน i ถึง j สามารถคำนวณได้โดยใช้ **prefix sum**
   - สร้างอาร์เรย์ prefix_sum ดังนี้:
     - prefix_sum[0] = 0
     - prefix_sum[1] = L[1]
     - prefix_sum[2] = L[1] + L[2]
     - ...
     - prefix_sum[N] = L[1] + L[2] + ... + L[N]
   - ผลรวมจากท่อน i ถึง j = prefix_sum[j] - prefix_sum[i-1]

2. **วิธีการตรวจสอบแบบพื้นฐาน (Brute Force):**
   - สำหรับแต่ละ Q_i ลูปทุกคู่ i, j แล้วคำนวณ prefix_sum[j] - prefix_sum[i-1] เทียบกับ Q_i
   - ความซับซ้อน: O(Q * N²)
   - ถ้า N = 1,000, Q = 100,000 จะได้ 100,000 * 1,000 * 1,000 = 10¹¹ ซึ่งช้ามากเกิน constraints (ปกติต้อง < 10⁸)

3. **การปรับปรุงให้เร็วขึ้น (Optimization):**
   - เนื่องจาก N ≤ 1,000 จำนวนช่วงต่อเนื่องกันทั้งหมดคือ N*(N+1)/2 ≈ 500,000 ช่วง
   - ผลรวมสูงสุด = 1,000 * 1,000,000 = 10⁹
   - เราสามารถ **precompute** ผลรวมของทุกช่วงที่เป็นไปได้ แล้วเก็บใน **set** เพื่อให้ตรวจสอบได้เร็ว
   - การ query ใน set มีความซับซ้อน O(log n) ถ้าใช้ set หรือ O(1) ถ้าใช้ unordered_set
   - ความซับซ้อนรวม:
     - สร้าง set: O(N²) ≈ 10⁶
     - Query Q ครั้ง: O(Q * log(N²)) ≈ 100,000 * log(500,000) ≈ 2 * 10⁶
     - รวม ≈ 3 * 10⁶ ซึ่งเร็วพอ

4. **ขั้นตอนการแก้ปัญหา:**
   - อ่าน N, Q และ L[1..N]
   - คำนวณ prefix sum
   - สร้าง set ที่เก็บผลรวมของทุกช่วงต่อเนื่องกัน
   - อ่าน Q คำถาม แล้วตรวจสอบว่าแต่ละ Q_i อยู่ใน set หรือไม่

5. **ข้อควรระวัง:**
   - ผลรวมอาจถึง 10⁹ ต้องใช้ long long (int ใน C++ เก็บได้ถึง 2 * 10⁹)
   - อาร์เรย์ใน C++ เริ่มที่ index 0 แต่โจทย์นับท่อนไม้จาก 1 ถึง N ต้องจัดการ index ให้ดี
   - L_i และ Q_i ≥ 1 ไม่ต้องกังวลกรณีผลรวมเป็น 0

---

### **การออกแบบโปรแกรม**

จากขั้นตอนการคิด ผมจะออกแบบโปรแกรมดังนี้:

- **โครงสร้างข้อมูล:**
  - `vector<int> L(N+1)` เก็บความยาวไม้ L[1] ถึง L[N]
  - `vector<long long> prefix_sum(N+1)` เก็บ prefix sum
  - `set<long long> possible_sums` เก็บผลรวมที่เป็นไปได้ทั้งหมด
  - `vector<int> queries(Q)` เก็บคำถาม Q ค่า

- **อัลกอริทึม:**
  1. อ่าน N และ Q
  2. อ่าน L[1] ถึง L[N]
  3. คำนวณ prefix_sum[0] = 0, prefix_sum[i] = prefix_sum[i-1] + L[i] สำหรับ i = 1 ถึง N
  4. วนลูป i จาก 1 ถึง N:
     - วนลูป j จาก i ถึง N:
       - คำนวณ sum = prefix_sum[j] - prefix_sum[i-1]
       - เพิ่ม sum เข้า possible_sums
  5. อ่าน Q ค่า Q_i
  6. สำหรับแต่ละ Q_i:
     - ถ้า Q_i อยู่ใน possible_sums ตอบ "Y" มิฉะนั้น "N"

---

### **โค้ดโปรแกรม**

```cpp
#include <iostream>
#include <vector>
#include <set>

using namespace std;

int main() {
    int N, Q;
    cin >> N >> Q;

    // อ่านความยาวไม้ N ท่อน
    vector<int> L(N + 1);
    for (int i = 1; i <= N; i++) {
        cin >> L[i];
    }

    // คำนวณ prefix sum
    vector<long long> prefix_sum(N + 1, 0);
    for (int i = 1; i <= N; i++) {
        prefix_sum[i] = prefix_sum[i - 1] + L[i];
    }

    // สร้าง set ของผลรวมที่เป็นไปได้
    set<long long> possible_sums;
    for (int i = 1; i <= N; i++) {
        for (int j = i; j <= N; j++) {
            long long sum = prefix_sum[j] - prefix_sum[i - 1];
            possible_sums.insert(sum);
        }
    }

    // อ่านคำถาม Q ข้อ
    vector<int> queries(Q);
    for (int i = 0; i < Q; i++) {
        cin >> queries[i];
    }

    // ตอบคำถาม
    for (int i = 0; i < Q; i++) {
        if (possible_sums.count(queries[i]) > 0) {
            cout << "Y";
        } else {
            cout << "N";
        }
        if (i < Q - 1) cout << " "; // ช่องว่างระหว่างคำตอบ
    }
    cout << endl;

    return 0;
}
```

---

### **อธิบายโค้ดทีละส่วน**

1. **รวมไลบรารีและ namespace**
   ```cpp
   #include <iostream>  // สำหรับ cin, cout
   #include <vector>    // สำหรับ vector
   #include <set>       // สำหรับ set
   using namespace std; // เพื่อให้ใช้ cin, cout โดยไม่ต้องใส่ std::
   ```
   - ใช้ `<vector>` สำหรับอาร์เรย์แบบ dynamic
   - ใช้ `<set>` เพื่อเก็บผลรวมแบบไม่ซ้ำและค้นหาได้เร็ว

2. **การอ่านข้อมูลนำเข้า**
   ```cpp
   int N, Q;
   cin >> N >> Q;
   vector<int> L(N + 1);
   for (int i = 1; i <= N; i++) {
       cin >> L[i];
   }
   ```
   - อ่าน N และ Q จากบรรทัดแรก
   - สร้าง vector L ขนาด N+1 (index 0 ไม่ใช้) แล้วอ่าน L[1] ถึง L[N]

3. **คำนวณ Prefix Sum**
   ```cpp
   vector<long long> prefix_sum(N + 1, 0);
   for (int i = 1; i <= N; i++) {
       prefix_sum[i] = prefix_sum[i - 1] + L[i];
   }
   ```
   - สร้าง vector prefix_sum ขนาด N+1 เริ่มต้นด้วย 0
   - คำนวณ prefix_sum[i] โดยบวก L[i] เข้ากับ prefix_sum[i-1]

4. **สร้าง Set ของผลรวม**
   ```cpp
   set<long long> possible_sums;
   for (int i = 1; i <= N; i++) {
       for (int j = i; j <= N; j++) {
           long long sum = prefix_sum[j] - prefix_sum[i - 1];
           possible_sums.insert(sum);
       }
   }
   ```
   - ใช้ set<long long> เพื่อเก็บผลรวม (ใช้ long long เพราะผลรวมสูงสุดถึง 10⁹)
   - ลูปสองชั้นเพื่อคำนวณผลรวมของทุกช่วง i ถึง j แล้วใส่ใน set
   - set จะกำจัดค่าซ้ำโดยอัตโนมัติ

5. **อ่านคำถาม**
   ```cpp
   vector<int> queries(Q);
   for (int i = 0; i < Q; i++) {
       cin >> queries[i];
   }
   ```
   - สร้าง vector queries ขนาด Q แล้วอ่าน Q_i

6. **ตอบคำถาม**
   ```cpp
   for (int i = 0; i < Q; i++) {
       if (possible_sums.count(queries[i]) > 0) {
           cout << "Y";
       } else {
           cout << "N";
       }
       if (i < Q - 1) cout << " "; // ช่องว่างระหว่างคำตอบ
   }
   cout << endl;
   ```
   - วนลูปตรวจสอบแต่ละ Q_i ว่าอยู่ใน possible_sums หรือไม่
   - ใช้ `count()` ซึ่งคืนค่า 1 ถ้ามี และ 0 ถ้าไม่มี
   - พิมพ์ "Y" หรือ "N" และเพิ่มช่องว่างถ้าไม่ใช่คำตอบสุดท้าย

---

### **ตัวอย่างการทำงาน**

**ข้อมูลนำเข้า:**
```
3 3
1 2 3
2 4 6
```

**ขั้นตอนการประมวลผล:**

1. **อ่านข้อมูล**
   - N = 3, Q = 3
   - L = [-, 1, 2, 3] (index 0 ไม่ใช้)
   - queries = [2, 4, 6]

2. **คำนวณ prefix sum**
   - prefix_sum[0] = 0
   - prefix_sum[1] = 0 + 1 = 1
   - prefix_sum[2] = 1 + 2 = 3
   - prefix_sum[3] = 3 + 3 = 6

3. **สร้าง possible_sums**
   - i=1, j=1: 1-0 = 1
   - i=1, j=2: 3-0 = 3
   - i=1, j=3: 6-0 = 6
   - i=2, j=2: 3-1 = 2
   - i=2, j=3: 6-1 = 5
   - i=3, j=3: 6-3 = 3
   - possible_sums = {1, 2, 3, 5, 6}

4. **ตอบคำถาม**
   - Q_1 = 2: อยู่ใน set → "Y"
   - Q_2 = 4: ไม่อยู่ → "N"
   - Q_3 = 6: อยู่ใน set → "Y"

**ข้อมูลส่งออก:**
```
Y N Y
```

---

### **สรุป**

โปรแกรมนี้แก้ปัญหาโดยใช้ prefix sum เพื่อคำนวณผลรวมของช่วงต่อเนื่องกันได้อย่างรวดเร็ว จากนั้น precompute ผลรวมทั้งหมดใส่ใน set แล้วตรวจสอบคำถามแต่ละข้อ ความซับซ้อนรวมประมาณ O(N² + Q * log(N²)) ซึ่งเหมาะสมกับ constraints (N ≤ 1,000, Q ≤ 100,000) และจัดการผลรวมที่อาจถึง 10⁹ ได้โดยใช้ long long โค้ดทำงานถูกต้องตามโจทย์และให้ผลลัพธ์ตามรูปแบบที่กำหนด