หลักการคิดและการทำงานของโค้ดในการจำลองระบบ Caching

ระบบ Caching ที่เรากำลังพัฒนาเป็นระบบที่จัดการกับการเก็บหน้าเว็บใน Cache ซึ่งสามารถเก็บหน้าเว็บได้สูงสุด N หน้า และต้องสามารถจัดการกับการ "hit" และ "miss" ของหน้าเว็บที่ถูกขอได้อย่างมีประสิทธิภาพ.

ในกรณีนี้ เรามีการออกแบบระบบ caching ที่ใช้โครงสร้างข้อมูล deque (double-ended queue) และ unordered_map เพื่อให้สามารถจัดการการเก็บหน้าเว็บใน Cache และการตรวจสอบว่าเป็น hit หรือ miss ได้อย่างรวดเร็ว.

หลักการคิด:
เมื่อมีการขอหน้าเว็บ:
- Hit: ถ้าหน้าเว็บที่ถูกขออยู่ใน Cache (เช็คจาก unordered_map), จะไม่ต้องไปดึงข้อมูลใหม่จาก server และจะมีการอัปเดตสถานะของหน้าเว็บ (นำไปไว้ที่ท้าย deque เพื่อให้เป็นหน้าเว็บที่ถูกใช้งานล่าสุด).
- Miss: ถ้าหน้าเว็บที่ถูกขอไม่อยู่ใน Cache, จะต้องดึงข้อมูลใหม่จาก server และเก็บมันไว้ใน Cache. ถ้า Cache เต็ม (มีข้อมูลอยู่แล้ว N หน้า), จะต้องลบหน้าเว็บที่เก่าที่สุดออก (หน้าเว็บที่อยู่หน้าแรกของ deque) และแทนที่ด้วยหน้าเว็บใหม่ที่ถูกขอ.

โครงสร้างข้อมูลที่ใช้:
- unordered_map: ใช้สำหรับเก็บการแมป (mapping) หน้าเว็บกับตำแหน่งใน deque ซึ่งช่วยให้สามารถเช็คสถานะ hit หรือ miss และเข้าถึงข้อมูลได้รวดเร็ว.
- deque: เก็บหน้าเว็บในลำดับการใช้งานจากหน้าเว็บที่ถูกใช้ล่าสุดไปยังหน้าเว็บที่ถูกใช้ก่อนหน้านั้น (แบบ FIFO). สามารถเพิ่มและลบข้อมูลจากทั้งสองด้านในเวลา O(1).

การทำงานของโค้ด:
ตัวแปรที่ใช้ในโค้ด:
- unordered_map<int, deque<int>::iterator> cache: เก็บหน้าเว็บใน Cache พร้อมกับตำแหน่งที่มันอยู่ใน deque. ใช้ในการเช็คว่า หน้าเว็บที่ถูกขอมีอยู่ใน Cache หรือไม่.
- deque<int> order: ใช้เก็บหน้าเว็บในลำดับการใช้งาน (จากหน้าเว็บที่ถูกใช้ล่าสุดไปยังหน้าเว็บที่ถูกใช้ก่อน). หน้าเว็บที่อยู่หน้าแรกใน deque คือหน้าเว็บที่เก่าที่สุด.
- misses: ตัวแปรนี้ใช้ในการนับจำนวนครั้งที่เกิด miss (การที่หน้าเว็บไม่อยู่ใน Cache).

ขั้นตอนการทำงาน:
การเริ่มต้น:
- Cache เริ่มต้นเป็นค่าว่าง (cache = {}) และ deque ก็จะเริ่มต้นเป็นค่าว่างด้วย (order = {}).

การขอหน้าเว็บ (ในลูป):
สำหรับแต่ละคำขอหน้าเว็บ (จากอินพุต):
1. เช็คว่า หน้าเว็บที่ขออยู่ใน Cache หรือไม่โดยดูจาก unordered_map:
   - ถ้า hit: เอาหน้าเว็บออกจาก deque และใส่กลับไปที่ท้ายเพื่อให้เป็นหน้าเว็บที่ใช้งานล่าสุด.
   - ถ้า miss: เพิ่มหน้าเว็บเข้าไปที่ท้าย deque.
     - ถ้า Cache เต็ม (จำนวนหน้าเว็บใน deque เกิน N): ลบหน้าเว็บที่เก่าที่สุด (หน้าเว็บที่อยู่ที่หน้าแรกของ deque). ลบหน้าเว็บที่ถูกลบออกจาก Cache โดยการลบจาก unordered_map. เพิ่มหน้าเว็บใหม่ที่ถูกขอเข้าไปใน Cache และ deque.

ผลลัพธ์:
หลังจากลูปทั้งหมดเสร็จสิ้น, เราจะแสดงผลลัพธ์จำนวน miss ที่เกิดขึ้น.

การทำงานในโค้ด:
เมื่อมีคำขอหน้าเว็บ (ID ของหน้าเว็บ):
- หากเป็น "hit": หน้าเว็บจะถูกย้ายไปที่ท้าย deque เพื่อทำให้มันเป็นหน้าเว็บที่ใช้งานล่าสุด.
- หากเป็น "miss": หน้าเว็บใหม่จะถูกเพิ่มเข้าไปใน deque, ถ้า Cache เต็ม, หน้าเว็บที่เก่าที่สุดจะถูกลบออก (จากหน้าแรกของ deque), และ Cache จะถูกอัปเดต.

ตัวอย่างอินพุตและผลลัพธ์:
อินพุต:
```
3 7
1
2
3
2
5
3
1
```

ผลลัพธ์:
```
5
```

อธิบายผลลัพธ์:
- คำขอที่ 1: Miss, เพิ่มหน้าเว็บ 1 เข้าสู่ Cache.
- คำขอที่ 2: Miss, เพิ่มหน้าเว็บ 2 เข้าสู่ Cache.
- คำขอที่ 3: Miss, เพิ่มหน้าเว็บ 3 เข้าสู่ Cache.
- คำขอที่ 4: Hit, หน้าเว็บ 2 อยู่ใน Cache แล้ว.
- คำขอที่ 5: Miss, เพิ่มหน้าเว็บ 5 และลบหน้าเว็บที่เก่าที่สุด (หน้าเว็บ 1).
- คำขอที่ 6: Hit, หน้าเว็บ 3 อยู่ใน Cache แล้ว.
- คำขอที่ 7: Miss, เพิ่มหน้าเว็บ 1 และลบหน้าเว็บที่เก่าที่สุด (หน้าเว็บ 2).

สรุป:
โค้ดนี้จำลองกระบวนการ Cache Misses โดยใช้ deque และ unordered_map เพื่อให้การทำงานมีประสิทธิภาพในการจัดการ Cache ที่มีข้อจำกัดขนาดและจัดการกับคำขอได้อย่างรวดเร็ว.