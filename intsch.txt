โค้ดนี้เป็นโปรแกรมที่ใช้ในการจัดการกับการกำหนดเวลาของงาน (tasks) โดยพยายามเลือกงานที่สามารถทำได้มากที่สุดในเวลาที่กำหนด โดยไม่ให้เวลาของงานชนกัน โดยใช้แนวคิดของ กิจกรรมที่เลือก (Activity Selection Problem) ซึ่งจะเลือกงานที่เสร็จเร็วที่สุดในแต่ละช่วงเวลาเพื่อให้สามารถเลือกงานอื่นๆ ได้มากที่สุด

การทำงานของโค้ด:
โครงสร้าง Timetmp:

ใช้เพื่อเก็บข้อมูลของงานแต่ละชิ้น ประกอบด้วย start (เวลาที่เริ่มต้น) และ end (เวลาที่สิ้นสุด)
ฟังก์ชัน compare:

ฟังก์ชันนี้ใช้ในการเปรียบเทียบงานสองชิ้น เพื่อให้สามารถจัดเรียงงานตามลำดับเวลา:
หากเวลาสิ้นสุด (end) ของงานทั้งสองชิ้นเท่ากัน, จะเปรียบเทียบตามเวลาที่เริ่มต้น (start), โดยจะเลือกงานที่เริ่มต้นก่อน
หากเวลาสิ้นสุดของงานต่างกัน, จะเปรียบเทียบตามเวลาสิ้นสุด, โดยเลือกงานที่สิ้นสุดก่อน
ฟังก์ชัน main:

อ่านจำนวนงาน (N) และเวลาของแต่ละงาน (start และ end)
จัดเรียงงานทั้งหมดโดยใช้ sort ตามลำดับเวลาสิ้นสุด (และเริ่มต้นหากเวลาสิ้นสุดเท่ากัน)
จากนั้นทำการวนลูปผ่านงานทั้งหมดและเลือกงานที่สามารถทำได้ (งานที่เริ่มหลังจากงานที่เลือกเสร็จแล้ว)
ถ้างานนั้นสามารถทำได้ (เริ่มหลังจากงานก่อนหน้าเสร็จ), จะเพิ่มจำนวนงานที่ทำได้ (count) และอัพเดตเวลาเสร็จของงานล่าสุด (endTask)
การแสดงผล:

แสดงผลลัพธ์เป็นจำนวนงานที่สามารถทำได้
ตัวอย่างการทำงาน:
สมมุติว่าเราให้เวลาของงาน 5 งานดังนี้:

คัดลอก
แก้ไข
1 3
2 5
4 7
6 8
5 9
การจัดเรียงงานตามเวลาสิ้นสุดจะได้ลำดับดังนี้:

คัดลอก
แก้ไข
1 3
2 5
4 7
6 8
5 9
จากนั้นจะเลือกงานที่สามารถทำได้โดยการตรวจสอบว่าเวลาของงานเริ่มต้นไม่ชนกับเวลาของงานที่เลือกไว้ก่อนหน้า:

เลือกงานที่ 1 (เริ่มที่ 1, สิ้นสุดที่ 3)
เลือกงานที่ 2 (เริ่มที่ 4, สิ้นสุดที่ 7)
เลือกงานที่ 3 (เริ่มที่ 6, สิ้นสุดที่ 8)
ผลลัพธ์สุดท้ายคือ 3 เนื่องจากสามารถทำงานได้ทั้งหมด 3 งาน

ตัวอย่างอินพุตและผลลัพธ์:
อินพุต:

คัดลอก
แก้ไข
5
1 3
2 5
4 7
6 8
5 9
ผลลัพธ์:

คัดลอก
แก้ไข
3
ข้อสังเกต:
การใช้การจัดเรียงตามเวลาสิ้นสุด (greedy approach) เป็นวิธีที่ดีที่สุดในกรณีนี้ เนื่องจากการเลือกงานที่เสร็จเร็วที่สุดจะเปิดโอกาสให้เลือกงานอื่นๆ ได้มากที่สุด
โค้ดนี้ใช้การจัดเรียงด้วยฟังก์ชัน sort และ compare เพื่อให้ได้ลำดับงานที่เหมาะสมที่สุด
ผลลัพธ์จะเป็นจำนวนของงานที่สามารถทำได้โดยไม่ให้เวลาทับซ้อนกัน