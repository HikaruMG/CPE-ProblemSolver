โค้ดนี้เป็นการแก้ปัญหา **Topological Sorting** ซึ่งเป็นอัลกอริทึมที่ใช้กับกราฟแบบมีทิศทาง (Directed Acyclic Graph - DAG) เพื่อเรียงลำดับโหนด (nodes) โดยที่โหนดที่มีการพึ่งพาจะถูกจัดลำดับหลังโหนดที่มันพึ่งพาอยู่ ในที่นี้ใช้ **Kahn's Algorithm** ซึ่งเป็นวิธีหนึ่งในการทำ Topological Sort โดยใช้คิว (queue) และการนับ **indegree** (จำนวนขอบที่ชี้เข้ามายังโหนด)

---

### **โจทย์และขั้นตอนการคิด**
โจทย์นี้ต้องการให้เรารับข้อมูลกราฟที่มีโหนด \(n\) โหนด และขอบ \(m\) ขอบ (edges) โดย:
1. รับจำนวนโหนด \(n\) และจำนวนขอบ \(m\) จากผู้ใช้
2. รับข้อมูลขอบในรูปแบบคู่ของตัวเลข \(u, v\) ซึ่งหมายถึงมีขอบจาก \(u\) ไป \(v\)
3. ทำ Topological Sort บนกราฟนี้
4. แสดงลำดับโหนดที่ได้จากการเรียงลำดับ
5. หยุดการทำงานเมื่อ \(n = 0\) และ \(m = 0\)

#### **ขั้นตอนการคิด**
1. **การแทนกราฟ**: ใช้ **adjacency list** (ในโค้ดคือ `vector<vector<int>> graph`) เพื่อเก็บข้อมูลขอบของกราฟ โดย `graph[u]` จะเก็บรายการโหนดที่ \(u\) ชี้ไปหา
2. **นับ Indegree**: ใช้เวกเตอร์ `Indg` เพื่อเก็บจำนวนขอบที่ชี้เข้ามายังแต่ละโหนด (indegree)
3. **Topological Sort**:
   - หาโหนดที่ไม่มีขอบชี้เข้ามา (indegree = 0) แล้วใส่ในคิว
   - นำโหนดออกจากคิวทีละตัว และลด indegree ของโหนดที่มันชี้ไป
   - ถ้า indegree ของโหนดใดลดลงเหลือ 0 ให้ใส่โหนดนั้นในคิว
   - ทำซ้ำจนกว่าคิวจะว่าง
4. **แสดงผล**: แสดงลำดับโหนดที่ได้จากการเรียงลำดับ

---

### **อธิบายโค้ดทีละส่วน**

#### **ส่วนหัวของโค้ด**
```cpp
#include <bits/stdc++.h>
using namespace std;
```
- `#include <bits/stdc++.h>`: รวมไลบรารีทั้งหมดของ C++ (เช่น `<vector>`, `<queue>`, `<iostream>` เป็นต้น) เพื่อให้สามารถใช้งานฟังก์ชันและโครงสร้างข้อมูลได้
- `using namespace std;`: เพื่อให้ไม่ต้องระบุ `std::` นำหน้าฟังก์ชันมาตรฐาน เช่น `cout`, `vector`

---

#### **ฟังก์ชัน T (Topological Sort)**
```cpp
void T(vector<vector<int>> graph, vector<int> indg , int n){
```
- **พารามิเตอร์**:
  - `graph`: adjacency list ที่เก็บข้อมูลกราฟ (โหนดที่แต่ละโหนดชี้ไป)
  - `indg`: เวกเตอร์ที่เก็บ indegree ของแต่ละโหนด
  - `n`: จำนวนโหนดในกราฟ

```cpp
    queue<int> q;
    vector<int> ans;
```
- `q`: คิวสำหรับเก็บโหนดที่ indegree = 0
- `ans`: เวกเตอร์สำหรับเก็บลำดับโหนดที่ได้จากการเรียงลำดับ

```cpp
    for(int i = 1; i<=n; i++){
        if(indg[i] == 0){
            q.push(i);
        }
    }
```
- ลูปผ่านโหนดทั้งหมด (เริ่มจาก 1 ถึง \(n\))
- ถ้าโหนดใดมี indegree = 0 (ไม่มีขอบชี้เข้ามา) ให้ใส่ในคิว

```cpp
    while(!q.empty()){
        int node = q.front();
        q.pop();
        ans.push_back(node);
```
- เข้าสู่ลูปหลักของ Kahn's Algorithm:
  - นำโหนดแรกออกจากคิว (`q.front()`) และลบออก (`q.pop()`)
  - เพิ่มโหนดนั้นใน `ans`

```cpp
        for(int temp : graph[node]){
            indg[temp]--;
            if(indg[temp]==0){
                q.push(temp);
            }
        }
```
- ลูปผ่านโหนดที่ `node` ชี้ไป (เก็บใน `graph[node]`)
- ลด indegree ของโหนดที่ถูกชี้ (`indg[temp]--`)
- ถ้า indegree ลดลงเหลือ 0 ให้เพิ่มโหนดนั้นในคิว

```cpp
    for(int j = 0;j<ans.size();j++){
        cout << ans[j] << " ";
    }
    cout << endl;
```
- แสดงลำดับโหนดใน `ans` โดยเว้นช่องว่างระหว่างตัวเลข และขึ้นบรรทัดใหม่เมื่อจบ

---

#### **ฟังก์ชัน main**
```cpp
int main(){
    int n,m;
    while(1){
        cin >> n >> m;
        if(m==0 and n==0){
            break;
        }
```
- รับค่า \(n\) (จำนวนโหนด) และ \(m\) (จำนวนขอบ)
- ถ้า \(n = 0\) และ \(m = 0\) ให้หยุดการทำงาน (ออกจากลูป)

```cpp
        vector<vector<int>> graph(n+1);
        vector<int> Indg(n+1,0);
```
- สร้าง `graph` ขนาด \(n+1\) (เริ่มจาก 1 ถึง \(n\)) เพื่อเก็บ adjacency list
- สร้าง `Indg` ขนาด \(n+1\) และกำหนดค่าเริ่มต้นเป็น 0 เพื่อเก็บ indegree

```cpp
        for(int j = 0;j<m;j++){
            int u,v;
            cin >> u >> v;
            graph[u].push_back(v);
            Indg[v]++;
        }
```
- รับข้อมูลขอบ \(m\) ขอบ:
  - รับค่า \(u\) และ \(v\) ซึ่งหมายถึงขอบจาก \(u\) ไป \(v\)
  - เพิ่ม \(v\) ใน `graph[u]` (แสดงว่า \(u\) ชี้ไป \(v\))
  - เพิ่ม indegree ของ \(v\) (`Indg[v]++`)

```cpp
        T(graph,Indg,n);
    }
    return 0;
}
```
- เรียกฟังก์ชัน `T` เพื่อทำ Topological Sort และแสดงผล
- วนลูปกลับไปรับข้อมูลกราฟใหม่จนกว่าจะเจอ \(n = 0\) และ \(m = 0\)

---

### **ตัวอย่างการทำงาน**
#### **Input:**
```
4 5
1 2
1 3
2 4
3 4
4 1
0 0
```

#### **การประมวลผล:**
1. **กราฟแรก (\(n = 4, m = 5\)):**
   - ขอบ: \(1 \to 2\), \(1 \to 3\), \(2 \to 4\), \(3 \to 4\), \(4 \to 1\)
   - **Indegree:**
     - \(Indg[1] = 1\) (จาก 4)
     - \(Indg[2] = 1\) (จาก 1)
     - \(Indg[3] = 1\) (จาก 1)
     - \(Indg[4] = 2\) (จาก 2 และ 3)

2. **เริ่ม Topological Sort:**
   - **รอบที่ 1:**
     - ไม่มีโหนดใดที่ indegree = 0 (มีวงจร \(1 \to 2 \to 4 \to 1\))
     - คิวว่างเปล่า ดังนั้น `ans` จะว่างเปล่า
   - **ผลลัพธ์:** ไม่มีการแสดงผลที่ถูกต้องตามหลัก Topological Sort เนื่องจากกราฟนี้มีวงจร (cyclic) ซึ่งไม่สามารถทำ Topological Sort ได้

#### **Output:**
```
```
(ว่างเปล่า เนื่องจากไม่มีลำดับที่ถูกต้อง)

#### **หมายเหตุ:**
- โค้ดนี้สมมติว่ากราฟเป็น DAG (ไม่มีวงจร) ถ้ามีวงจร (เช่นในตัวอย่างนี้) จะไม่สามารถหาลำดับ Topological Sort ได้ และผลลัพธ์อาจไม่สมบูรณ์
- หากต้องการตรวจสอบวงจร ต้องเพิ่มโค้ดเพื่อตรวจว่า `ans.size() == n` หรือไม่ ถ้าไม่เท่ากัน แปลว่ามีวงจร

#### **ตัวอย่างที่ถูกต้อง (DAG):**
**Input:**
```
4 3
1 2
2 3
3 4
0 0
```
- **Indegree:**
  - \(Indg[1] = 0\)
  - \(Indg[2] = 1\)
  - \(Indg[3] = 1\)
  - \(Indg[4] = 1\)
- **ขั้นตอน:**
  - รอบ 1: \(q = [1]\), \(ans = [1]\), ลด \(Indg[2] = 0\)
  - รอบ 2: \(q = [2]\), \(ans = [1, 2]\), ลด \(Indg[3] = 0\)
  - รอบ 3: \(q = [3]\), \(ans = [1, 2, 3]\), ลด \(Indg[4] = 0\)
  - รอบ 4: \(q = [4]\), \(ans = [1, 2, 3, 4]\)
- **Output:**
```
1 2 3 4
```

---

### **สรุป**
- โค้ดนี้ใช้ Kahn's Algorithm ในการทำ Topological Sort
- เหมาะสำหรับกราฟ DAG เท่านั้น ถ้ามีวงจรจะไม่ทำงานอย่างถูกต้อง
- การทำงานเริ่มจากโหนดที่ไม่มีขอบชี้เข้ามา และค่อยๆ ลด indegree ของโหนดที่เกี่ยวข้อง
- ผลลัพธ์คือลำดับโหนดที่เรียงตามการพึ่งพา