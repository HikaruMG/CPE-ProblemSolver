หลักการคิดและการทำงานของโค้ด
โปรแกรมนี้มีจุดประสงค์เพื่อหาวันที่ช้าที่สุดที่สามารถแบ่งนักปิงปองออกเป็นสองทีมได้ โดยที่สมาชิกในแต่ละทีมจะไม่เคยแข่งขันกันมาก่อน การแบ่งนี้สามารถเทียบได้กับการตรวจสอบว่า กราฟที่สร้างจากการแข่งขันนั้นสามารถแบ่งเป็นสองกลุ่ม (bipartite) ได้หรือไม่

ขั้นตอนหลักในการคิดและการทำงานของโค้ด:
1. การสร้างกราฟ (Graph Construction)
เราจะมองนักปิงปองเป็น โหนด (nodes) และการแข่งขันระหว่างนักปิงปองเป็น ขอบ (edges) ที่เชื่อมโยงระหว่างโหนดสองโหนด
เมื่อมีการแข่งขันระหว่างนักปิงปองคน A และ B ในวันที่ i ก็หมายความว่าเราจะเพิ่มขอบระหว่างโหนด A และ B ในกราฟ
2. การตรวจสอบว่าเป็น Bipartite หรือไม่
การแบ่งกลุ่มของนักปิงปองที่ไม่เคยแข่งขันกันมาก่อนสามารถเปรียบเทียบได้กับการตรวจสอบว่า กราฟนั้นเป็น Bipartite หรือไม่
กราฟ Bipartite คือกราฟที่สามารถแบ่งโหนดออกเป็นสองกลุ่มโดยที่โหนดที่เชื่อมโยงกันจะไม่อยู่ในกลุ่มเดียวกัน
วิธีการตรวจสอบว่าเป็น Bipartite หรือไม่คือการทำ coloring โดยใช้ BFS หรือ DFS ซึ่งจะพยายามกำหนดสีให้กับโหนด:
ถ้าโหนดสองโหนดที่เชื่อมโยงกันมีสีเดียวกัน แสดงว่ากราฟไม่เป็น Bipartite
ถ้าโหนดที่เชื่อมโยงกันมีสีต่างกัน ก็แสดงว่าเป็น Bipartite
หากสามารถแบ่งกราฟออกเป็นสองกลุ่มได้ (ไม่มีโหนดสองโหนดที่เชื่อมโยงกันมีสีเดียวกัน) ก็คือการแบ่งนักปิงปองออกเป็นสองทีมที่ไม่เคยแข่งขันกันมาก่อน
3. การใช้ Binary Search
เราต้องการหาวันที่ช้าที่สุดที่สามารถแบ่งนักปิงปองออกเป็นสองทีมได้ ดังนั้นเราจึงใช้ Binary Search เพื่อค้นหาวันที่ดีที่สุด:
เริ่มต้นจากการทดสอบวันที่ 1 ถึง m (จำนวนวันทั้งหมด)
ในแต่ละวัน i เราจะสร้างกราฟการแข่งขันจนถึงวันนั้น และตรวจสอบว่าเป็น Bipartite หรือไม่
ถ้าในวันนั้นสามารถแบ่งนักปิงปองออกเป็นสองทีมได้ (คือกราฟเป็น Bipartite) เราจะลองหาวันที่มากขึ้น (ปรับ left ไปที่ mid + 1)
ถ้าไม่สามารถแบ่งได้ เราจะลดช่วงค้นหาลง (ปรับ right ไปที่ mid - 1)
4. การทำงานของโปรแกรม
4.1 การอ่านข้อมูล
รับข้อมูลจำนวน n (จำนวนของนักปิงปอง) และ m (จำนวนคู่การแข่งขัน)
รับข้อมูลการแข่งขันในรูปแบบของคู่ (A, B) ซึ่งบ่งบอกว่าในวันที่ i นักปิงปอง A จะแข่งขันกับนักปิงปอง B
4.2 ฟังก์ชัน isBipartite
สร้างกราฟจากการแข่งขันในช่วงวันที่ 1 ถึง day
ใช้ BFS ในการทดสอบว่าเราสามารถแบ่งกราฟเป็นสองกลุ่มได้หรือไม่
ถ้าไม่สามารถแบ่งได้ (พบโหนดสองโหนดที่เชื่อมโยงกันและมีสีเดียวกัน) คืนค่า false
ถ้าสามารถแบ่งได้ (ทุกโหนดที่เชื่อมโยงกันมีสีต่างกัน) คืนค่า true
4.3 การใช้ Binary Search
เราจะใช้ binary search ในการค้นหาวันที่ช้าที่สุดที่สามารถแบ่งนักปิงปองออกเป็นสองกลุ่มได้
เมื่อพบวันที่สามารถแบ่งได้ เราจะขยายขอบเขตการค้นหาต่อไป
เมื่อไม่สามารถแบ่งได้ในวันไหน เราจะลดขอบเขตการค้นหา
4.4 ผลลัพธ์
หลังจากทำการค้นหาจนเสร็จ ผลลัพธ์ที่ได้คือวันที่ช้าที่สุดที่ยังสามารถแบ่งนักปิงปองออกเป็นสองกลุ่มได้
5. ตัวอย่างการทำงานของโค้ด
ตัวอย่างที่ 1:
Input:

คัดลอก
แก้ไข
3 3
1 2
2 3
1 3
การทำงาน:

ในวันที่ 1: มีการแข่งขันระหว่าง 1 และ 2
ในวันที่ 2: มีการแข่งขันระหว่าง 2 และ 3
ในวันที่ 3: มีการแข่งขันระหว่าง 1 และ 3
ถ้าเราแบ่งนักปิงปองในวันที่ 2 จะสามารถแบ่งออกเป็นสองกลุ่มได้ (กลุ่ม 1: {1, 3}, กลุ่ม 2: {2}) เพราะไม่มีใครในกลุ่มเดียวกันที่เคยแข่งขันกัน
ดังนั้นคำตอบคือวันที่ 2
Output:

คัดลอก
แก้ไข
2
ตัวอย่างที่ 2:
Input:

คัดลอก
แก้ไข
5 7
1 2
2 3
3 4
4 5
5 1
2 4
3 5
การทำงาน:

ตรวจสอบการแข่งขันจนถึงวันที่ 6 และพบว่าสามารถแบ่งนักปิงปองได้
แต่วันที่ 7 ไม่สามารถแบ่งได้เนื่องจากมีการแข่งขันระหว่าง 3 และ 5 ซึ่งทำให้ไม่สามารถแบ่งออกเป็นสองกลุ่มได้
Output:

คัดลอก
แก้ไข
6
สรุป:
โปรแกรมใช้ BFS เพื่อตรวจสอบการแบ่งกลุ่ม (bipartite checking) และใช้ binary search เพื่อหาวันที่ช้าที่สุดที่ยังสามารถแบ่งกลุ่มได้
โดยใช้แนวคิดของกราฟและการทดสอบความเป็น bipartite ในการแก้ปัญหานี้