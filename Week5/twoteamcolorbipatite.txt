หลักการคิดและการทำงานของโค้ด
โปรแกรมนี้มีจุดประสงค์เพื่อหาวันที่ช้าที่สุดที่สามารถแบ่งนักปิงปองออกเป็นสองทีมได้ โดยที่สมาชิกในแต่ละทีมจะไม่เคยแข่งขันกันมาก่อน การแบ่งนี้สามารถเทียบได้กับการตรวจสอบว่า กราฟที่สร้างจากการแข่งขันนั้นสามารถแบ่งเป็นสองกลุ่ม (bipartite) ได้หรือไม่

ขั้นตอนหลักในการคิดและการทำงานของโค้ด:
1. การสร้างกราฟ (Graph Construction)
   เราจะมองนักปิงปองเป็น โหนด (nodes) และการแข่งขันระหว่างนักปิงปองเป็น ขอบ (edges) ที่เชื่อมโยงระหว่างโหนดสองโหนด
   เมื่อมีการแข่งขันระหว่างนักปิงปองคน A และ B ในวันที่ i ก็หมายความว่าเราจะเพิ่มขอบระหว่างโหนด A และ B ในกราฟ

2. การตรวจสอบว่าเป็น Bipartite หรือไม่
   การแบ่งกลุ่มของนักปิงปองที่ไม่เคยแข่งขันกันมาก่อนสามารถเปรียบเทียบได้กับการตรวจสอบว่า กราฟนั้นเป็น Bipartite หรือไม่
   กราฟ Bipartite คือกราฟที่สามารถแบ่งโหนดออกเป็นสองกลุ่มโดยที่โหนดที่เชื่อมโยงกันจะไม่อยู่ในกลุ่มเดียวกัน
   วิธีการตรวจสอบว่าเป็น Bipartite หรือไม่คือการทำ coloring โดยใช้ BFS หรือ DFS ซึ่งจะพยายามกำหนดสีให้กับโหนด:
   - ถ้าโหนดสองโหนดที่เชื่อมโยงกันมีสีเดียวกัน แสดงว่ากราฟไม่เป็น Bipartite
   - ถ้าโหนดที่เชื่อมโยงกันมีสีต่างกัน ก็แสดงว่าเป็น Bipartite
   หากสามารถแบ่งกราฟออกเป็นสองกลุ่มได้ (ไม่มีโหนดสองโหนดที่เชื่อมโยงกันมีสีเดียวกัน) ก็คือการแบ่งนักปิงปองออกเป็นสองทีมที่ไม่เคยแข่งขันกันมาก่อน

3. การใช้ Binary Search
   เราต้องการหาวันที่ช้าที่สุดที่สามารถแบ่งนักปิงปองออกเป็นสองทีมได้ ดังนั้นเราจึงใช้ Binary Search เพื่อค้นหาวันที่ดีที่สุด:
   - เริ่มต้นจากการทดสอบวันที่ 1 ถึง m (จำนวนวันทั้งหมด)
   - ในแต่ละวัน i เราจะสร้างกราฟการแข่งขันจนถึงวันนั้น และตรวจสอบว่าเป็น Bipartite หรือไม่
   - ถ้าในวันนั้นสามารถแบ่งนักปิงปองออกเป็นสองทีมได้ (คือกราฟเป็น Bipartite) เราจะลองหาวันที่มากขึ้น (ปรับ left ไปที่ mid + 1)
   - ถ้าไม่สามารถแบ่งได้ เราจะลดช่วงค้นหาลง (ปรับ right ไปที่ mid - 1)

4. การทำงานของโปรแกรม
   4.1 การอ่านข้อมูล
       รับข้อมูลจำนวน n (จำนวนของนักปิงปอง) และ m (จำนวนคู่การแข่งขัน)
       รับข้อมูลการแข่งขันในรูปแบบของคู่ (A, B) ซึ่งบ่งบอกว่าในวันที่ i นักปิงปอง A จะแข่งขันกับนักปิงปอง B
   4.2 ฟังก์ชัน isBipartite
       สร้างกราฟจากการแข่งขันในช่วงวันที่ 1 ถึง day
       ใช้ BFS ในการทดสอบว่าเราสามารถแบ่งกราฟเป็นสองกลุ่มได้หรือไม่
       - ถ้าไม่สามารถแบ่งได้ (พบโหนดสองโหนดที่เชื่อมโยงกันและมีสีเดียวกัน) คืนค่า false
       - ถ้าสามารถแบ่งได้ (ทุกโหนดที่เชื่อมโยงกันมีสีต่างกัน) คืนค่า true
   4.3 การใช้ Binary Search
       เราจะใช้ binary search ในการค้นหาวันที่ช้าที่สุดที่สามารถแบ่งนักปิงปองออกเป็นสองกลุ่มได้
       - เมื่อพบวันที่สามารถแบ่งได้ เราจะขยายขอบเขตการค้นหาต่อไป
       - เมื่อไม่สามารถแบ่งได้ในวันไหน เราจะลดขอบเขตการค้นหา
   4.4 ผลลัพธ์
       หลังจากทำการค้นหาจนเสร็จ ผลลัพธ์ที่ได้คือวันที่ช้าที่สุดที่ยังสามารถแบ่งนักปิงปองออกเป็นสองกลุ่มได้

5. ตัวอย่างการทำงานของโค้ด
   ตัวอย่างที่ 1:
   Input:
   3 3
   1 2
   2 3
   1 3
   การทำงาน:
   - ในวันที่ 1: มีการแข่งขันระหว่าง 1 และ 2
   - ในวันที่ 2: มีการแข่งขันระหว่าง 2 และ 3
   - ในวันที่ 3: มีการแข่งขันระหว่าง 1 และ 3
   ถ้าเราแบ่งนักปิงปองในวันที่ 2 จะสามารถแบ่งออกเป็นสองกลุ่มได้ (กลุ่ม 1: {1, 3}, กลุ่ม 2: {2}) เพราะไม่มีใครในกลุ่มเดียวกันที่เคยแข่งขันกัน
   ดังนั้นคำตอบคือวันที่ 2
   Output:
   2

   ตัวอย่างที่ 2:
   Input:
   5 7
   1 2
   2 3
   3 4
   4 5
   5 1
   2 4
   3 5
   การทำงาน:
   - ตรวจสอบการแข่งขันจนถึงวันที่ 6 และพบว่าสามารถแบ่งนักปิงปองได้
   - แต่วันที่ 7 ไม่สามารถแบ่งได้เนื่องจากมีการแข่งขันระหว่าง 3 และ 5 ซึ่งทำให้ไม่สามารถแบ่งออกเป็นสองกลุ่มได้
   Output:
   6

สรุป:
โปรแกรมใช้ BFS เพื่อตรวจสอบการแบ่งกลุ่ม (bipartite checking) และใช้ binary search เพื่อหาวันที่ช้าที่สุดที่ยังสามารถแบ่งกลุ่มได้
โดยใช้แนวคิดของกราฟและการทดสอบความเป็น bipartite ในการแก้ปัญหานี้